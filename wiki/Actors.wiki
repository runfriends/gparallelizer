#summary Use of Actors - the message-passing based Scala-like actors library
#labels Featured,Phase-Design,Phase-Implementation

_Actors_ in GParallelizer were inspired by Actors library in Scala. They allow for messaging-based concurrency model, built from independent active objects that exchange messages and have no mutable shared state. Actors can naturally avoid issues like deadlocks, livelocks or starvation, so typical for shared memory.
A nice wrap-up of the key [http://ruben.savanne.be/articles/concurrency-in-erlang-scala concepts behind actors] was written recently by Ruben Vermeersch

= Types of Actors =

*GParallelizer* comes with two types of actors, both of which have their uses. _Thread-bound actors_ maintain their own thread of execution, whereas _event-driven actors_ share a common thread pool, from which they borrow threads whenever they must react to an event - typically a message sent to them. 

== Event-driven actors ==

Although _thread-bound actors_ can perform better in some scenarios and are probably a good default choice when it comes to long calculation tasks, they exhibit scalability limitations due to the natural limits for the number of concurrently run threads imposed by current HW platforms. _Event-driven actors_, which share a relatively small thread pool and avoid these threading limitations, on the other hand, are a bit trickier to use since they require computing tasks to be detachable from and re-attachable to the underlying threads. Actor's code is processed in chunks separated by quiet periods of waiting for new events (messages). This can be naturally modeled through _continuations_. As JVM doesn't support continuations directly, they have to be simulated in the actors frameworks, which has slight impact on organization of the actors' code. However, the benefits in most cases outweigh the difficulties. 

{{{
import org.gparallelizer.actors.pooledActors.AbstractPooledActor

class GameMaster extends AbstractPooledActor {
       int secretNum

       void afterStart()
       {
               secretNum = new Random().nextInt(10)
       }

       void act()
       {
               loop
               {
                       react { int num ->
                               if      ( num > secretNum )
                                       reply 'too large'
                               else if ( num < secretNum )
                                       reply 'too small'
                               else
                               {
                                       reply 'you win'
                                       stop()
                               }
                       }
               }
       }
}

class Player extends AbstractPooledActor {
       String              name
       AbstractPooledActor server
       int                 myNum

       void act()
       {
               loop
               {
                       myNum = new Random().nextInt(10)

                       server.send myNum

                       react {
                               switch( it )
                               {
                                       case 'too large': println "$name: $myNum was too large"; break
                                       case 'too small': println "$name: $myNum was too small"; break
                                       case 'you win':   println "$name: I won $myNum"; stop(); break
                               }
                       }
               }
       }
}

def master = new GameMaster().start()
new Player( name: 'Player', server: master ).start()
}}}
example by _Jordi Campos i Miralles, Departament de Matemàtica Aplicada i Anàlisi, MAiA Facultat de Matemàtiques, Universitat de Barcelona_
= Usage of Actors =

*GParallelizer* provides consistent API and DSL for both _thread-bound actors_ and _event-driven actors_. The differences in use are only marginal and relate to the different threading nature of these two types of actors.

== Event-driven actors ==

_Event-driven actors_ share a *pool* of threads, which are dynamically assigned to actors when the actors need to *react* to messages sent to them. The threads are returned to back the pool once a message has been processed and the actor is idle waiting for some more messages to arrive.

For example, this is how you create an actor that prints out all messages that it receives.

{{{
def console = actor {
    loop {
        react {
            println it
        }
    }
}
}}}

Notice the _loop()_ method call, which ensures that the actor doesn't stop after having processed the first message.

Here's an example with a decryptor service, which can decrypt submitted messages and send the decrypted messages back to the originators.

{{{
import static org.gparallelizer.actors.pooledActors.PooledActors.*

final def decryptor = actor {
    loop {
        react {String message->
            if ('stopService' == message) stop()
            else reply message.reverse()
        }
    }
}.start()

actor {
    decryptor.send 'suonorhcnysa si yvoorG'
    react {
        println 'Decrypted message: ' + it
        decryptor.send 'stopService'
    }
}.start()
}}}

Here's an example of an actor that waits for up to 30 seconds to receive a message, prints it out and terminates.

{{{
import static org.gparallelizer.actors.pooledActors.PooledActors.*

def me = actor {
    friend.send('Hi')
    react(10.seconds) {
        //continue conversation
    }
}.start()

me.metaClass.onTimeout = {->friend.send('I see, busy as usual. Never mind.')}
}}}

See more detailed documentation on [http://code.google.com/p/gparallelizer/wiki/EventDrivenActors Use of event-driven actors]

== Thread-bound actors ==

_Thread-bound actors_ have their own thread, which is always available to receive and process new messages sent to the actor. When waiting for a message to arrive, the thread is blocked.

For example, this is how you create an actor that prints out all messages that it receives.

{{{
def console = Actors.actor {
    println receive()
}
}}}

Alternatively you can extend one of the Actor's classes and override the act() method.

{{{
class CustomActor extends BoundedActor {
    @Override protected void act() {
        println receive()
    }
}

def console=new CustomActor()
}}}

Once you have the actor, you need to start it so that it creates its background thread and can accept messages.

{{{
console.start()
console.send('Message')
}}}
Here's an example of an actor that waits for up to 30 seconds to receive a message, prints it out and terminates. Something I call a one-shot actor.

{{{
def notifier = Actors.oneShotActor {
    println receive(30.seconds) ?: 'No message'
}
}}}

Notice the possible alternative way to retrieve the received value from the receive() method - the value is passed as a parameter into a closure.

{{{
def notifier = Actors.oneShotActor {
    receive(30.seconds) {
        println it?:'No message'
    }
}
}}}

See more detailed documentation on [http://code.google.com/p/gparallelizer/wiki/ThreadBoundActors Use of thread-bound actors]

==Sending replies==

The _reply/replyIfExists_ methods are not only defined on the actors themselves, but also on the messages upon their reception, which is particularly handy when accepting multiple messages in a single call. In such cases _reply()_ invoked on the actor sends a reply to authors of all the currently processed messages, whereas _reply()_ called on messages sends a reply to the author of the particular message only.

{{{
react {offerA, offerB, offerC ->
    
    //sent to each of the senders
    reply 'Received your kind offer. Now processing it and comparing with others.'

    offerA.reply 'You were the fastest'  //sent to the author of offerA only

    def winnerOffer = [offerA, offerB, offerC].min {it.price}
    winnerOffer.reply 'I accept your reasonable offer'  //sent to the winner only
}

The reply/replyIfExists methods work reliably across the actor types, so that event-driven (pooled) actors can send replies to thread-bound actors and vice versa.

{{{
//a thread-bound actor
final Actor doubler = Actors.actor {
    receive {num ->
        reply 2 * num
    }
}.start()

//an event-driven actor
PooledActors.actor {
    doubler << 10
    doubler << 100
    react {a, b ->
        println "Doubles for 10 and 100 are $a and $b"
    }
}.start()
}}}
}}}