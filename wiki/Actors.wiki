#summary Use of Actors - the message-passing based Scala-like actors library
#labels Featured,Phase-Design,Phase-Implementation

_Actors_ in GParallelizer were inspired by Actors library in Scala. They allow for messaging-based concurrency model, built from independent active objects that exchange messages and have no mutable shared state. Actors naturally avoid issues like deadlocks, livelocks or starvation, so typical for shared memory.

= Usage of Actors =

For example, this is how you create an actor that prints out all messages that it receives.

{{{
def actor = Actors.actor {
    println receive()
}
}}}

Alternativelly you can extend one of the Actor's classes and override the act() method.

{{{
class CustomActor extends BoundedActor {
    @Override protected void act() {
        println receive()
    }
}

def actor=new CustomActor()
}}}

Once you have the actor, you need to start it so that it creates its background thread and can accept messages.

{{{
actor.start()
actor.send('Message')
}}}

Groovy's flexible syntax with closures allows our library to offer multiple ways to define actors. For instance, here's an example of an actor that waits for up to 30 seconds to receive a message, prints it out and terminates. Something I call a one-shot actor.

{{{
def actor = Actors.oneShotActor {
    println receive(30, TimeUnit.SECONDS) ?: 'No message'
}
}}}

Notice the possible alternative way to retrieve the received value from the receive() method - the value is passed as a parameter into a closure.

{{{
def actor = Actors.oneShotActor {
    receive(30, TimeUnit.SECONDS) {
        println it?:'No message'
    }
}
}}}

For comparison I'm including a more involved example performing a concurrent merge sort of a list of integers using actors. You can see that thanks to flexibility of Groovy we came pretty close to the Scala's model, although I still miss Scala's pattern matching for message handling.

{{{
Closure createMessageHandler(def parentActor) {
    return {
        receive {List<Integer> message ->
            assert message != null
            switch (message.size()) {
                case 0..1:
                    parentActor.send(message)
                    break
                case 2:
                    if (message[0] <= message[1]) parentActor.send(message)
                    else parentActor.send(message[-1..0])
                    break
                default:
                    def splitList = split(message)

                    def child1 = Actors.oneShotActor(createMessageHandler(delegate))
                    def child2 = Actors.oneShotActor(createMessageHandler(delegate))
                    child1.start().send(splitList[0])
                    child2.start().send(splitList[1])

                    parentActor.send merge(receive(), receive())
            }
        }
    }

}

def resultActor = Actors.oneShotActor {
    println "Sorted array:\t${receive()}"
}.start()

def sorter = Actors.oneShotActor(createMessageHandler(resultActor))
sorter.start().send([1, 5, 2, 4, 3, 8, 6, 7, 3, 4, 5, 2, 2, 9, 8, 7, 6, 7, 8, 1, 4, 1, 7, 5, 8, 2, 3, 9, 5, 7, 4, 3])
}}}

For brevity I didn't include the two helper methods split() and merge() in the code snippet. You can find them below.
{{{
def split(List<Integer> list) {
    int listSize = list.size()
    int middleIndex = listSize / 2
    def list1 = list[0..<middleIndex]
    def list2 = list[middleIndex..listSize - 1]
    return [list1, list2]
}

List<Integer> merge(List<Integer> a, List<Integer> b) {
    int i = 0, j = 0
    final int newSize = a.size() + b.size()
    List<Integer> result = new ArrayList<Integer>(newSize)

    while ((i < a.size()) && (j < b.size())) {
        if (a[i] <= b[j]) result << a[i++]
        else result << b[j++]
    }

    if (i < a.size()) result.addAll(a[i..-1])
    else result.addAll(b[j..-1])
    return result
}
}}}

===Actors creation===
_GParallelizer_ provides multiple Actor classes, which differ in the type of the message queue. For example, the DefaultActor uses unbounded queue, BoundedActor uses a bounded one and the SynchronousActor uses an SynchronousQueue, where send() and receive() operations must meet for both to proced further.

Actors have their _act()_ method run periodically by the actors' thread until the _stop()_ method is called on the Actor.

Developers may either extend one of the Actor classes and override the _act()_ method or use one of the helper methods in the _Actors_ class to create an Actor around a supplied closure.

So called one-shot actors have the _stop()_ method called automatically after the _act()_ method finishes the first time. They are aimed at handling non-repeating tasks.