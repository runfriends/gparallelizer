#summary Use of Actors - the message-passing based Scala-like actors library
#labels Featured,Phase-Design,Phase-Implementation

_Actors_ in GParallelizer were inspired by Actors library in Scala. They allow for messaging-based concurrency model, built from independent active objects that exchange messages and have no mutable shared state. Actors naturally avoid issues like deadlocks, livelocks or starvation, so typical for shared memory.

= Types of Actors =

*GParallelizer* comes with two types of actors, both of which have their uses. _Thread-bound actors_ maintain their own thread of execution, whereas _event-driven actors_ (scheduled for the 0.6 release) share a common thread pool, from which they borrow threads whenever they must react to an event - typically a message sent to them. 

== Event-driven actors ==

Although _thread-bound actors_ can perform better in some, typically low contention, scenarios, they exhibit scalability limitations due to the natural limits of concurrently run threads imposed by current HW platforms. _Event-driven actors_, which share a relatively small thread pool and avoid these threading limitations, on the other hand, are a bit trickier to use since they require computing tasks to be detachable from and re-attachable to the underlying threads. Actor's code is processed in chunks separated by quiet periods of waiting for new events (messages). This can be naturally modeled through _continuations_. As JVM doesn't support continuations directly, they have to be simulated in the actors frameworks, which has slight impact on organization of the actors' code. However, the benefits in most cases outweigh the difficulties. 

= Usage of Actors =

*GParallelizer* provides consistent API and DSL for both _thread-bound actors_ and _event-driven actors_. The differences in use are only marginal and relate to the different threading nature of these two types of actors.

== Thread-bound actors ==

_Thread-bound actors_ have their own thread, which is always available to receive and process new messages sent to the actor.

For example, this is how you create an actor that prints out all messages that it receives.

{{{
def actor = Actors.actor {
    println receive()
}
}}}

Alternativelly you can extend one of the Actor's classes and override the act() method.

{{{
class CustomActor extends BoundedActor {
    @Override protected void act() {
        println receive()
    }
}

def actor=new CustomActor()
}}}

Once you have the actor, you need to start it so that it creates its background thread and can accept messages.

{{{
actor.start()
actor.send('Message')
}}}

Groovy's flexible syntax with closures allows our library to offer multiple ways to define actors. For instance, here's an example of an actor that waits for up to 30 seconds to receive a message, prints it out and terminates. Something I call a one-shot actor.

{{{
def actor = Actors.oneShotActor {
    println receive(30.seconds) ?: 'No message'
}
}}}

Notice the possible alternative way to retrieve the received value from the receive() method - the value is passed as a parameter into a closure.

{{{
def actor = Actors.oneShotActor {
    receive(30.seconds) {
        println it?:'No message'
    }
}
}}}

See more detailed documentation on [http://code.google.com/p/gparallelizer/wiki/ThreadBoundActors Use of thread-bound actors]

== Event-driven actors ==

_Event-driven actors_ share a *pool* of threads, which are dynamically assigned to actors when the actors need to *react* to a message sent to them. The threads are returned to back the pool once the message has been processed and the actor is idle waiting for some more messages to arrive.

For example, this is how you create an actor that prints out all messages that it receives.

{{{
def actor = PooledActors.actor {
    loop {
        react {
            println it
        }
    }
}}}

Notice the loop() method call, which ensures that the actor doesn't stop after having processed the first message. Alternatively you can extend one of the PooledActor's classes and override the act() method.

{{{
class CustomActor extends AbstractPooledActor {
    @Override protected void act() {
        loop [
            react {
                println it
            }
        }
    }
}

def actor=new CustomActor()
}}}

Once you have the actor, you need to start it so that it attaches itself to the thread pool and can start accepting messages.

{{{
actor.start()
actor.send('Message')
}}}

Groovy's flexible syntax with closures allows our library to offer multiple ways to define actors. For instance, here's an example of an actor that waits for up to 30 seconds to receive a message, prints it out and terminates.

{{{
def actor = PooledActors.actor {
    react(30.seconds) {
        println it
    }
}
}}}

See more detailed documentation on [http://code.google.com/p/gparallelizer/wiki/EventDrivenActors Use of event-driven actors]