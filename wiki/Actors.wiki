#summary Use of Actors - the message-passing based Scala-like actors library
#labels Featured,Phase-Design,Phase-Implementation

= Usage of Actors =

For example, this is how you create an actor that prints out all messages that it receives.

{{{
def actor = Actors.actor {
    println receive()
}
}}}

Alternativelly you can extend one of the Actor's classes and override the act() method.

{{{
class CustomActor extends BoundedActor {
    @Override protected void act() {
        println receive()
    }
}

def actor=new CustomActor()
}}}

Once you have the actor, you need to start it so that it creates its background thread and can accept messages.

{{{
actor.start()
actor.send('Message')
}}}

Groovy's flexible syntax with closures allows our library to offers multiple ways to define actors. For instance, here's an example of an actor that waits for up to 30 seconds to receive a message, prints it out and terminates, something I call a one-shot actor.

{{{
def actor = Actors.oneShotActor {
    println receive(30, TimeUnit.SECONDS) ?: 'No message'
}
}}}

Notice the possible alternative way to retrieve the reseived value from the receive() method - the value is passed as a parameter into a closure.

{{{
def actor = Actors.oneShotActor {
    receive(30, TimeUnit.SECONDS) {
        println it?:'No message'
    }
}
}}}

For comparison I'm including a more involved example performing a concurrent merge sort of a list of integers using actors. You can see that thanks to flexibility of Groovy we came pretty close to the Scala's model, although I still miss Scala's pattern matching for message handling.

{{{
Closure createMessageHandler(def parentActor) {
    return {
        receive {List<Integer> message ->
            assert message != null
            switch (message.size()) {
                case 0..1:
                    parentActor.send(message)
                    break
                case 2:
                    if (message[0] <= message[1]) parentActor.send(message)
                    else parentActor.send(message[-1..0])
                    break
                default:
                    def splitList = split(message)

                    def child1 = Actors.oneShotActor(createMessageHandler(delegate))
                    def child2 = Actors.oneShotActor(createMessageHandler(delegate))
                    child1.start().send(splitList[0])
                    child2.start().send(splitList[1])

                    parentActor.send merge(receive(), receive())
            }
        }
    }

}

def resultActor = Actors.oneShotActor {
    println "Sorted array:\t${receive()}"
}.start()

def sorter = Actors.oneShotActor(createMessageHandler(resultActor))
sorter.start().send([1, 5, 2, 4, 3, 8, 6, 7, 3, 4, 5, 2, 2, 9, 8, 7, 6, 7, 8, 1, 4, 1, 7, 5, 8, 2, 3, 9, 5, 7, 4, 3])
}}}

For brevity I didn't include the two helper methods split() and merge() in the code snippet. You can find them below.
{{{
def split(List<Integer> list) {
    int listSize = list.size()
    int middleIndex = listSize / 2
    def list1 = list[0..<middleIndex]
    def list2 = list[middleIndex..listSize - 1]
    return [list1, list2]
}

List<Integer> merge(List<Integer> a, List<Integer> b) {
    int i = 0, j = 0
    final int newSize = a.size() + b.size()
    List<Integer> result = new ArrayList<Integer>(newSize)

    while ((i < a.size()) && (j < b.size())) {
        if (a[i] <= b[j]) result << a[i++]
        else result << b[j++]
    }

    if (i < a.size()) result.addAll(a[i..-1])
    else result.addAll(b[j..-1])
    return result
}
}}}