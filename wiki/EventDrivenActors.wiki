#summary Event-driven actors share a pool of threads to process messages asynchronously.
#labels Featured,Phase-Design,Phase-Implementation

= Use of event-driven actors =

_Event-driven actors_ share a *pool* of threads, which are dynamically assigned to actors when the actors need to *react* to a message sent to them. The threads are returned to back the pool once the message has been processed and the actor is idle waiting for some more messages to arrive.

For example, this is how you create an actor that prints out all messages that it receives.

{{{
def actor = PooledActors.actor {
    loop {
        react {
            println it
        }
    }
}}}

Notice the loop() method call, which ensures that the actor doesn't stop after having processed the first message. Alternatively you can extend one of the PooledActor's classes and override the act() method.

{{{
class CustomActor extends AbstractPooledActor {
    @Override protected void act() {
        loop [
            react {
                println it
            }
        }
    }
}

def actor=new CustomActor()
}}}

Once you have the actor, you need to start it so that it attaches itself to the thread pool and can start accepting messages.

{{{
actor.start()
actor.send('Message')
}}}

Groovy's flexible syntax with closures allows our library to offer multiple ways to define actors. For instance, here's an example of an actor that waits for up to 30 seconds to receive a message, prints it out and terminates.

{{{
def actor = PooledActors.actor {
    react(30.seconds) {
        println it
    }
}
}}}

===Simple calculator===

A little bit more realistic example of an event-driven actor that receives two numeric messages, sums them up and sends the result to the console actor.
{{{
import static org.gparallelizer.actors.pooledActors.PooledActors.*

//not necessary, just showing that a single-threaded pool can still handle multiple actors
getPool().initialize 1

final def console = actor {
    loop {
        react {
            println 'Result: ' + it
        }
    }
}.start()

final def calculator = actor {
    react {a ->
        react {b ->
            console.send(a + b)
        }
    }
}.start()

calculator.send 2
calculator.send 3
}}}

Notice that event-driven actors require special care regarding the _react()_ method. Since _event_driven actors_ need to split the code into independent chunks assignable to different threads sequentially and *continuations* are not natively supported on JVM, the chunks are created artificially with tasks and exceptions. As a result the _react()_ and _loop()_ methods never return normally and actors' code must be structured accordingly. Again, this is in line with what Scala actors do.
 
===Concurrent Merge Sort Example===

For comparison I'm also including a more involved example performing a concurrent merge sort of a list of integers using actors. You can see that thanks to flexibility of Groovy we came pretty close to the Scala's model, although I still miss Scala's pattern matching for message handling.

{{{
Closure createMessageHandler(def parentActor) {
    return {
        receive {List<Integer> message ->
            assert message != null
            switch (message.size()) {
                case 0..1:
                    parentActor.send(message)
                    break
                case 2:
                    if (message[0] <= message[1]) parentActor.send(message)
                    else parentActor.send(message[-1..0])
                    break
                default:
                    def splitList = split(message)

                    def child1 = Actors.oneShotActor(createMessageHandler(delegate))
                    def child2 = Actors.oneShotActor(createMessageHandler(delegate))
                    child1.start().send(splitList[0])
                    child2.start().send(splitList[1])

                    parentActor.send merge(receive(), receive())
            }
        }
    }

}

def resultActor = Actors.oneShotActor {
    println "Sorted array:\t${receive()}"
}.start()

def sorter = Actors.oneShotActor(createMessageHandler(resultActor))
sorter.start().send([1, 5, 2, 4, 3, 8, 6, 7, 3, 4, 5, 2, 2, 9, 8, 7, 6, 7, 8, 1, 4, 1, 7, 5, 8, 2, 3, 9, 5, 7, 4, 3])
}}}

For brevity I didn't include the two helper methods split() and merge() in the code snippet. You can find them below.
{{{
def split(List<Integer> list) {
    int listSize = list.size()
    int middleIndex = listSize / 2
    def list1 = list[0..<middleIndex]
    def list2 = list[middleIndex..listSize - 1]
    return [list1, list2]
}

List<Integer> merge(List<Integer> a, List<Integer> b) {
    int i = 0, j = 0
    final int newSize = a.size() + b.size()
    List<Integer> result = new ArrayList<Integer>(newSize)

    while ((i < a.size()) && (j < b.size())) {
        if (a[i] <= b[j]) result << a[i++]
        else result << b[j++]
    }

    if (i < a.size()) result.addAll(a[i..-1])
    else result.addAll(b[j..-1])
    return result
}
}}}

===Actors creation===
_GParallelizer_ provides multiple Actor classes, which differ in the type of the message queue. For example, the DefaultActor uses unbounded queue, BoundedActor uses a bounded one and the SynchronousActor uses an SynchronousQueue, where send() and receive() operations must meet for both to proced further.

Actors have their _act()_ method run periodically by the actors' thread until the _stop()_ method is called on the Actor. So called one-shot actors have the _stop()_ method called automatically after the _act()_ method finishes the first time. They are aimed at handling non-repeating tasks.

Developers may either extend one of the Actor classes and override the _act()_ method or use one of the helper methods in the _Actors_ class to have an Actor created around a supplied closure.

===Actor lifecycle methods===
Each Actor can define lifecycle observing methods, which will be called by the Actor's background thread whenever a certain lifecycle event occurs.
  * afterStart() - called immediatelly after the Actor's background thread has been started, before the act() method is called the first time.
  * beforeStop() - called right before the actor stops.
  * afterStop(List undeliveredMessages) - called right after the actor is stopped, passing in all the messages from the queue.
  * onInterrupt(InterruptedException e) - called when the actor's thread gets interrupted. Thread interruption will result in the stopping the actor in any case.
  * onException(Throwable e) - called when an exception occurs in the actor's thread. Throwing an exception from this method will stop the actor.

You can either define the methods statically in your Actor class or add them dynamically to the actor's metaclass:
{{{
def actor = Actors.actor {...}

actor.metaClass.onException = {
    log.error('Exception occured', it)
    if (it instanceof Error) throw it
}
}}}

===TimeCategory DSL use===
Actors allow time DSL defined by org.codehaus.groovy.runtime.TimeCategory class to be used for timeout specification to the receive() method.
{{{
def me = Actors.actor {
    friend.send('Hi')
    def reply = receive(10.seconds)
    if (!reply) friend.send('I said Hi! Are your there man?')
}
}}}

===Actors as Mixins===
As of 0.5 release actors can be mixed into other classes.
{{{
        Company.metaClass {
            mixin DefaultActor

            act = {->
                receive {
                    println it
                }
            }

            afterStop = {List undeliveredMessages ->
                ...
            }
        }

final Company company = new Company(name: 'Company1', employees: ['Joe', 'Dave', 'Alice'])
company.start()
company.send("Message")
...
company.stop()
}}}

Actors can also extend individual instances only.
{{{
final Company company = new Company(name: 'Company1', employees: ['Joe', 'Dave', 'Alice'])

company.metaClass {
    mixin DefaultActor

    act = {->
        receive {
            println it
        }
    }
}

company.start()
company.send("Message")
...
company.stop()

}}}