<html>
     <head>
     	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
     	<title>8.1 Declarative Transactions</title>
     	<link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8">
     </head>
	<body class="body">
		<h3>Default Declarative Transactions</h3><p class="paragraph"/>Services are typically involved with co-ordinating logic between <a href="../guide/single.html#5. Object Relational Mapping (GORM)" class="guide">domain classes</a>, and hence often involved with persistence that spans large operations. Given the nature of services they frequently require transactional behaviour. You can of course use programmatic transactions with the <a href="../ref/Domain Classes/withTransaction.html" class="domainClasses">withTransaction</a> method, however this is repetitive and doesn't fully leverage the power of Spring's underlying transaction abstraction.<p class="paragraph"/>Services allow the enablement of transaction demarcation, which is essentially a declarative way of saying all methods within this service are to be made transactional. All services have transaction demarcation enabled by default - to disable it, simply set the <code>transactional</code> property to <code>false</code>:<p class="paragraph"/><div class="code"><pre>class CountryService &#123;
    <span class="java&#45;keyword">static</span> transactional = <span class="java&#45;keyword">false</span>
&#125;</pre></div><p class="paragraph"/>You may also set this property to <code>true</code> in case the default changes in the future, or simply to make it clear that the service is intentionally transactional.<p class="paragraph"/><blockquote class="warning">
Warning: <a href="../guide/single.html#8.3 Dependency Injection and Services" class="guide">dependency injection</a> is the <strong class="bold">only</strong> way that declarative transactions work. You will not get a transactional service if you use the <code>new</code> operator such as <code>new BookService()</code>
</blockquote><p class="paragraph"/>
The result is all methods are wrapped in a transaction and automatic rollback occurs if an exception is thrown in the body of one of the methods. The propagation level of the transaction is by default set to <a href="http://static.springframework.org/spring/docs/2.0.x/api/org/springframework/transaction/TransactionDefinition.html#PROPAGATION_REQUIRED" target="blank">PROPAGATION_REQUIRED</a>.<p class="paragraph"/><h3>Custom Transaction Configuration</h3><p class="paragraph"/>Grails also fully supports Spring's <code>Transactional</code> annotation for cases where you need more fine-grained control over transactions at a per-method level or need specify an alternative propagation level:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> org.springframework.transaction.annotation.&#42;<p class="paragraph"/>class BookService &#123;<p class="paragraph"/>	@Transactional(readOnly = <span class="java&#45;keyword">true</span>) 
	def listBooks() &#123; Book.list() &#125;<p class="paragraph"/>	@Transactional def updateBook() &#123; 
		// É 
	&#125;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>For more information refer to the section of the Spring user guide on <a href="http://static.springsource.org/spring/docs/2.5.x/reference/transaction.html#transaction-declarative-annotations" target="blank">Using @Transactional</a>.<p class="paragraph"/><blockquote class="note">
Unlike Spring you do not need any prior configuration to use <code>Transactional</code>, just specify the annotation as needed and Grails will pick them up automatically.
</blockquote>
	</body>
</html>