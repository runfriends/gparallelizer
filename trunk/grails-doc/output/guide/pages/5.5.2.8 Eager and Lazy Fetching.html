<html>
     <head>
     	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
     	<title>5.5.2.8 Eager and Lazy Fetching</title>
     	<link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8">
     </head>
	<body class="body">
		<h5>Lazy Collections</h5><p class="paragraph"/>As discussed in the section on <a href="../guide/single.html#5.3.4 Eager and Lazy Fetching" class="guide">Eager and Lazy fetching</a>, by default GORM collections use lazy fetching and is is configurable through the <code>fetchMode</code> setting. However, if you prefer to group all your mappings together inside the <code>mappings</code> block you can also use the ORM DSL to configure fetching:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  <span class="java&#45;object">String</span> firstName
  <span class="java&#45;keyword">static</span> hasMany = &#91;addresses:Address&#93;
  <span class="java&#45;keyword">static</span> mapping = &#123;
      addresses lazy:<span class="java&#45;keyword">false</span>
  &#125;
&#125;
class Address &#123;
  <span class="java&#45;object">String</span> street
  <span class="java&#45;object">String</span> postCode
&#125;</pre></div><p class="paragraph"/><h4>Lazy Single-Ended Associations</h4><p class="paragraph"/>In GORM, one-to-one and many-to-one associations are by default lazy. Non-lazy single ended associations can be problematic in cases when you are loading many entities which have an association to another entity as a new SELECT statement is executed for each loaded entity.<p class="paragraph"/>You can make one-to-one and many-to-one associations non-lazy using the same technique as for lazy collections:<p class="paragraph"/><div class="code"><pre>class Person &#123;
	<span class="java&#45;object">String</span> firstName
	<span class="java&#45;keyword">static</span> belongsTo = &#91;address:Address&#93;
	<span class="java&#45;keyword">static</span> mapping = &#123;
		address lazy:<span class="java&#45;keyword">false</span>
	&#125;
&#125;
class Address &#123;
	<span class="java&#45;object">String</span> street
	<span class="java&#45;object">String</span> postCode
&#125;</pre></div><p class="paragraph"/>Here we set the <code>address</code> property of the <code>Person</code> class will be eagerly fetched.<p class="paragraph"/><h4>Lazy Single-Ended Associations and Proxies</h4><p class="paragraph"/>In order to facilitate single-ended lazy associations Hibernate uses runtime generated proxies. The way this works is that Hibernate dynamically subclasses the proxied entity to create the proxy.<p class="paragraph"/>In the previous example Hibernate would create a subclass of <code>Address</code> and return that as a proxy to the real entity. When you call any of the getters or setters Hibernate will initialize the the entity from the database.<p class="paragraph"/>Unfortunately this technique can produce surprising results. Consider the following example classes:<p class="paragraph"/><div class="code"><pre>class Animal &#123;&#125;
class Mammal <span class="java&#45;keyword">extends</span> Animal &#123;&#125;
class Dog <span class="java&#45;keyword">extends</span> Mammal &#123;
	<span class="java&#45;object">String</span> name
&#125;
class Owner &#123;
	Animal pet
&#125;</pre></div><p class="paragraph"/>Given you have an <code>Owner</code> with a <code>pet</code> association that is a <code>Dog</code> consider the following code:<p class="paragraph"/><div class="code"><pre>def owner = Owner.get(1)
def pet = Animal.get(owner.petId)
<span class="java&#45;keyword">if</span>(pet <span class="java&#45;keyword">instanceof</span> Dog) &#123;
	// doesn't work!
&#125;</pre></div><p class="paragraph"/>Now you may think this code will work, but in fact it will not. The reason is Hibernate creates a dynamic proxy by subclassing <code>Animal</code> for the <code>owner.pet</code> association and caches it in the first level cache. So even if the actual proxied class is a <code>Dog</code> it won't be an instance of the <code>Dog</code> class due to the way proxies work.<p class="paragraph"/>The get around this problem GORM provides an <code>instanceOf</code> method that should always be used:<p class="paragraph"/><div class="code"><pre>def owner = Owner.get(1)
def pet = Animal.get(owner.petId)
<span class="java&#45;keyword">if</span>(pet?.<span class="java&#45;keyword">instanceof</span>( Dog )) &#123;
	// <span class="java&#45;keyword">this</span> works
&#125;</pre></div><p class="paragraph"/>However, there are cases where this particular Hibernate abstraction may still leak through. For example:<p class="paragraph"/><div class="code"><pre>def owner = Owner.get(1)
Dog pet = Animal.get(owner.petId)</pre></div><p class="paragraph"/>In this case you will get a <code>ClassCastException</code> because the proxied <code>Animal</code> is not a <code>Dog</code> even though the actual instance <strong class="bold">is</strong> a <code>Dog</code>.<p class="paragraph"/>Our best advice is to be aware of Hibernate proxies and how to deal with them when you do run into issues.
	</body>
</html>