<html>
     <head>
     	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
     	<title>5.3.4 Eager and Lazy Fetching</title>
     	<link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8">
     </head>
	<body class="body">
		Associations in GORM are by default lazy. This is best explained by example:<p class="paragraph"/><div class="code"><pre>class Airport &#123;
	<span class="java&#45;object">String</span> name
	<span class="java&#45;keyword">static</span> hasMany = &#91;flights:Flight&#93;
&#125;
class Flight &#123;
	<span class="java&#45;object">String</span> number
	<span class="java&#45;keyword">static</span> belongsTo = &#91;airport:Airport&#93;
&#125;</pre></div><p class="paragraph"/>Given the above domain classes and the following code:<p class="paragraph"/><div class="code"><pre>def airport = Airport.findByName(<span class="java&#45;quote">"Gatwick"</span>)
airport.flights.each &#123;
	println it.name
&#125;</pre></div><p class="paragraph"/>GORM will execute a single SQL query to fetch the <code>Airport</code> instance and then 1 extra query <em class="italic">for each</em> iteration over the <code>flights</code> association. In other words you get N+1 queries.<p class="paragraph"/>This can sometimes be optimal depending on the frequency of use of the association as you may have logic that dictates the associations is only accessed on certain occasions.<p class="paragraph"/><h3>Configuring Eager Fetching</h3><p class="paragraph"/>An alternative is to use eager fetching which can specified as follows:<p class="paragraph"/><div class="code"><pre>class Airport &#123;
	<span class="java&#45;object">String</span> name
	<span class="java&#45;keyword">static</span> hasMany = &#91;flights:Flight&#93;
	<span class="java&#45;keyword">static</span> mapping = &#123;
		flight fetch:<span class="java&#45;quote">"join"</span>
	&#125;
&#125;</pre></div><p class="paragraph"/>In  this case the association will be <code>Airport</code> instance and the <code>flights</code> association will be loaded all at once (depending on the mapping). This has the benefit of requiring fewer queries, however should be used carefully as you could load your entire database into memory with too many eager associations.<p class="paragraph"/><blockquote class="note">
Associations can also be declared non-lazy using the <a href="../guide/single.html#5.5.2 Custom ORM Mapping" class="guide">ORM DSL</a>
</blockquote><p class="paragraph"/><h3>Using Batch Fetching</h3><p class="paragraph"/>Although eager fetching is appropriate for some cases, it is not always desirable. If you made everything eager you could quite possibly load your entire database into memory resulting in performance and memory problems. An alternative to eager fetching is to use batch fetching. Essentially, you can configure Hibernate to lazily fetch results in "batches". For example:<p class="paragraph"/><div class="code"><pre>class Airport &#123;
	<span class="java&#45;object">String</span> name
	<span class="java&#45;keyword">static</span> hasMany = &#91;flights:Flight&#93;
	<span class="java&#45;keyword">static</span> mapping = &#123;
		flight batchSize:10
	&#125;
&#125;</pre></div><p class="paragraph"/>In this case, due to the <code>batchSize</code> argument, when you iterate over the <code>flights</code> association, Hibernate will fetch results in batches of 10. For example if you had an <code>Airport</code> that had 30 flights, if you didn't configure batch fetching you would get 1 query to fetch the <code>Airport</code> and then <code>30</code> queries to fetch each flight. With batch fetching you get 1 query to fetch the <code>Airport</code> and 3 queries to fetch each <code>Flight</code> in batches of 10. In other words, batch fetching is an optimization of the lazy fetching strategy. Batch fetching can also be configured at the class level as follows:<p class="paragraph"/><div class="code"><pre>class Flight &#123;
	&#8230;
	<span class="java&#45;keyword">static</span> mapping = &#123;
		batchSize 10
	&#125;
&#125;</pre></div>

	</body>
</html>