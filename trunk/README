GParallelizer library defining a Groovy-based concurrency Domain Specific Language

+----------+
| Overview |
+----------+

GParallelizer allows Groovy code to easily handle tasks concurrently, leveraging either the JSR-166y Parallel Arrays
or Java's executor services.

The framework offers developers straightforward Groovy-based Domain Specific Languages (DSLs) to declare, which parts of the code
should be performed in parallel. Objects are enhanced with asynchronous methods like eachAsync(), collectAsync() and others,
to perform these collection-based operations in parallel. Closures can be turned into asynchronous variants, which when invoked
schedule the original closure for processing in an executor service. The library also provides helper methods for running
a bunch of closures concurrently.

The library has two logical parts, which differ in the implementation technology.
1. Parallelizer uses JSR-166y Parallel Arrays and is limited to collection processing.
2. Asynchronizer uses the Java 1.5 built-in support for executor services and supports not only collections and all other types,
   which can be iterated in Groovy. but also consurrent closures' execution.

+-----------------------+
| Usage of Parallelizer |
+-----------------------+

 The Parallelizer class enables a ParallelArray-based (from JSR-166y) DSL on collections. The jsr166y.jar (downloadable from e.g.
 http://gee.cs.oswego.edu/dl/concurrency-interest/index.html) must be on the classpath.

 Examples of use:

 //summarize numbers concurrently
 Parallelizer.withParallelizer(5) {
     final AtomicInteger result = new AtomicInteger(0)
     [1, 2, 3, 4, 5].eachAsync {result.addAndGet(it)}
     assertEquals 15, result
 }

 //multiply numbers asynchronously
 Parallelizer.withParallelizer(5) {
     final List result = [1, 2, 3, 4, 5].collectAsync {it * 2}
     assert ([2, 4, 6, 8, 10].equals(result))
 }

The passed-in closure takes an instance of a ForkJoinPool as a parameter.

 //check whether all elements within a collection meet certain criteria
 Parallelizer.withParallelizer(5) {ForkJoinPool pool ->
     assert [1, 2, 3, 4, 5].allAsync {it > 0}
     assert ![1, 2, 3, 4, 5].allAsync {it > 1}
 }

The Parallelizer.withParallelizer() method takes optional parameters for number of threads in the created pool
and unhandled exception handler. The Parallelizer.withExistingParallelizer() takes an already existing thread pool to reuse.
The DSL is valid only within the associated block of code and only for the thread that has called the withParallelizer()
or withExistingParallelizer() method.
The withParallelizer() method returns only after all the worker threads have finished their tasks and the pool has been destroyed,
returning back the return value of the associated block of code. The withExistingParallelizer() method doesn't wait for the pool
threads to finish.

The following methods on collections are currently supported:
eachAsync()
collectAsync()
findAllAsync()
findAsync()
allAsync()
anyAsync()

+------------------------+
| Usage of Asynchronizer |
+------------------------+

 The Asynchronizer class enables a Java's Executor Service-based DSL on collections and closures. At least Java 1.5 must be used.

 Examples of use:

 //multiply numbers asynchronously
 Asynchronizer.withAsynchronizer(5) {
     Collection<Future> result = [1, 2, 3, 4, 5].collectAsync{it * 10}
     assertEquals(new HashSet([10, 20, 30, 40, 50]), new HashSet((Collection)result*.get()))
 }

 //multiply numbers asynchronously using an asynchronous closure
 Asynchronizer.withAsynchronizer(5) {
     def closure={it * 10}
     def asyncClosure=closure.async()
     Collection<Future> result = [1, 2, 3, 4, 5].collect(asyncClosure)
     assertEquals(new HashSet([10, 20, 30, 40, 50]), new HashSet((Collection)result*.get()))
 }

 The passed-in closure takes an instance of a ExecutorService as a parameter.

 //find an element meeting specified criteria
 Asynchronizer.withAsynchronizer(5) {ExecutorService service ->
     def result = [1, 2, 3, 4, 5].findAsync{Number number -> number > 2}
     assert result in [3, 4, 5]
 }

The Asynchronizer.withAsynchronizer() method takes optional parameters for number of threads in the created pool
and a thread factory. The Asynchronizer.withExistingAsynchronizer() takes an already existing executor service to reuse.
The DSL is valid only within the associated block of code and only for the thread that has called the withAsynchronizer()
or withExistingAsynchronizer() method.
The withAsynchronizer() method returns only after all the worker threads have finished their tasks and the executor service
has been destroyed, returning back the return value of the associated block of code. The withExistingAsynchronizer() method
doesn't wait for the executor service threads to finish.


The following methods on all objects, which support iterations in Groovy, are currently supported:
eachAsync()
collectAsync()
findAllAsync()
findAsync()
allAsync()
anyAsync()

The following methods are added to closures inside the Asynchronizer.withAsynchronizer() blocks:
async() - Creates an asynchronous variant of the supplied closure, which when invoked returns a future for the potential return value
callAsync() - Calls a closure in a separate thread supplying the given arguments, returning a future for the potential return value,

Example:
Asynchronizer.withAsynchronizer() {
    Closure longLastingCalculation = {calculate()}
    Closure fastCalculation = longLastingCalculation.async()
    Future result=fastCalculation()
    //do stuff while calculation performs
    println result.get()
}


The ExecutorService class is enhanced with the << (leftShift) operator to submit tasks to it returning a Future for the result.
It wraps the submit() method call on the service.

Example:
Asynchronizer.withAsynchronizer {ExecutorService executorService ->
    executorService << {println 'Inside parallel task'}
}


The AsyncInvokerUtil class offers methods doInParallel, executeInParallel and startInParallel to easily run multiple closures in parallel.

Example:
Asynchronizer.withAsynchronizer {
    assertEquals([10, 20], AsyncInvokerUtil.doInParallel({calculateA()}, {calculateB()}))
}
