<html>
     <head>
     	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
     	<title>5.2.4 Sets, Lists and Maps</title>
     	<link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8">
     </head>
	<body class="body">
		<h4>Sets of objects</h4><p class="paragraph"/>By default when you define a relationship with GORM it is a <code>java.util.Set</code> which is an unordered collection that cannot contain duplicates. In other words when you have:<p class="paragraph"/><div class="code"><pre>class Author &#123;
   <span class="java&#45;keyword">static</span> hasMany = &#91;books:Book&#93;
&#125;</pre></div><p class="paragraph"/>The books property that GORM injects is a <code>java.util.Set</code>. The problem with this is there is no ordering when accessing the collection, which may not be what you want. To get custom ordering you can say that the set is a <code>SortedSet</code>:<p class="paragraph"/><div class="code"><pre>class Author &#123;
   SortedSet books
   <span class="java&#45;keyword">static</span> hasMany = &#91;books:Book&#93;
&#125;</pre></div><p class="paragraph"/>In this case a <code>java.util.SortedSet</code> implementation is used which means you have to implement <code>java.lang.Comparable</code> in your Book class:<p class="paragraph"/><div class="code"><pre>class Book <span class="java&#45;keyword">implements</span> Comparable &#123;
   <span class="java&#45;object">String</span> title
   Date releaseDate = <span class="java&#45;keyword">new</span> Date()<p class="paragraph"/>   <span class="java&#45;object">int</span> compareTo(obj) &#123;
       releaseDate.compareTo(obj.releaseDate)
   &#125;
&#125;</pre></div><p class="paragraph"/>The result of the above class is that the Book instances in the books collections of the Author class will be ordered by their release date.<p class="paragraph"/><h4>Lists of objects</h4><p class="paragraph"/>If you simply want to be able to keep objects in the order which they were added and to be able to reference them by index like an array you can define your collection type as a <code>List</code>:<p class="paragraph"/><div class="code"><pre>class Author &#123;
   List books
   <span class="java&#45;keyword">static</span> hasMany = &#91;books:Book&#93;
&#125;</pre></div><p class="paragraph"/>In this case when you add new elements to the books collection the order is retained in a sequential list indexed from 0 so you can do:<p class="paragraph"/><div class="code"><pre>author.books&#91;0&#93; // get the first book</pre></div><p class="paragraph"/>The way this works at the database level is Hibernate creates a <code>books_idx</code> column where it saves the index of the elements in the collection in order to retain this order at the db level.<p class="paragraph"/>When using a <code>List</code>, elements must be added to the collection before being saved, otherwise Hibernate will throw an exception (<code>org.hibernate.HibernateException</code>: null index column for collection):<p class="paragraph"/><div class="code"><pre>// This won't work!
def book = <span class="java&#45;keyword">new</span> Book(title: 'The Shining')
book.save()
author.addToBooks(book)<p class="paragraph"/>// Do it <span class="java&#45;keyword">this</span> way instead.
def book = <span class="java&#45;keyword">new</span> Book(title: 'Misery')
author.addToBooks(book)
author.save()</pre></div><p class="paragraph"/><h4>Maps of Objects</h4><p class="paragraph"/>If you want a simple map of string/value pairs GORM can map this with the following:<p class="paragraph"/><div class="code"><pre>class Author &#123;
   Map books // map of ISBN:book names
&#125;<p class="paragraph"/>def a = <span class="java&#45;keyword">new</span> Author()
a.books = &#91;<span class="java&#45;quote">"1590597583"</span>:<span class="java&#45;quote">"Grails Book"</span>&#93;
a.save()</pre></div>
In this case the key and value of the map MUST be strings.<p class="paragraph"/>If you want a Map of objects then you can do this:<p class="paragraph"/><div class="code"><pre>class Book &#123;
  Map authors
  <span class="java&#45;keyword">static</span> hasMany = &#91;authors:Author&#93;
&#125;<p class="paragraph"/>def a = <span class="java&#45;keyword">new</span> Author(name:<span class="java&#45;quote">"Stephen King"</span>)<p class="paragraph"/>def book = <span class="java&#45;keyword">new</span> Book()
book.authors = &#91;stephen:a&#93;
book.save()</pre></div><p class="paragraph"/>The static <code>hasMany</code> property defines the type of the elements within the Map. The keys for the map <strong class="bold">must</strong> be strings.<p class="paragraph"/><h4>A Note on Collection Types and Performance</h4><p class="paragraph"/>The Java <code>Set</code> type is a collection that doesn't allow duplicates. In order to ensure uniqueness when adding an entry to a <code>Set</code> association Hibernate has to load the entire associations from the database. If you have a large numbers of entries in the association this can be costly in terms of performance.<p class="paragraph"/>The same behavior is required for <code>List</code> types, since Hibernate needs to load the entire association in-order to maintain order. Therefore it is recommended that if you anticipate a large numbers of records in the association that you make the association bidirectional so that the link can be created on the inverse side. For example consider the following code:<p class="paragraph"/><div class="code"><pre>def book = <span class="java&#45;keyword">new</span> Book(title:<span class="java&#45;quote">"New Grails Book"</span>)
def author = Author.get(1)
book.author = author
book.save()</pre></div><p class="paragraph"/>In this example the association link is being created by the child (Book) and hence it is not necessary to manipulate the collection directly resulting in fewer queries and more efficient code. Given an <code>Author</code> with a large number of associated <code>Book</code> instances if you were to write code like the following you would see an impact on performance:<p class="paragraph"/><div class="code"><pre>def book = <span class="java&#45;keyword">new</span> Book(title:<span class="java&#45;quote">"New Grails Book"</span>)
def author = Author.get(1)
author.addToBooks(book)
author.save()</pre></div>
	</body>
</html>