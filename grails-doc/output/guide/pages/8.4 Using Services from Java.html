<html>
     <head>
     	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
     	<title>8.4 Using Services from Java</title>
     	<link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8">
     </head>
	<body class="body">
		One of the powerful things about services is that since they encapsulate re-usable logic, you can use them from other classes, including Java classes. There are a couple of ways you can re-use a service from Java. The simplest way is to move your service into a package within the <code>grails-app/services</code> directory. The reason this is a critical step is that it is not possible to import classes into Java from the default package (the package used when no package declaration is present). So for example the <code>BookService</code> below cannot be used from Java as it stands:<p class="paragraph"/><div class="code"><pre>class BookService &#123;
	void buyBook(Book book) &#123;
		// logic
	&#125;
&#125;</pre></div><p class="paragraph"/>However, this can be rectified by placing this class in a package, by moving the class into a sub directory such as <code>grails-app/services/bookstore</code> and then modifying the package declaration:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> bookstore
class BookService &#123;
	void buyBook(Book book) &#123;
		// logic
	&#125;
&#125;</pre></div><p class="paragraph"/>An alternative to packages is to instead have an interface within a package that the service implements:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> bookstore;
<span class="java&#45;keyword">interface</span> BookStore &#123;
	void buyBook(Book book);
&#125;</pre></div><p class="paragraph"/>And then the service:<p class="paragraph"/><div class="code"><pre>class BookService <span class="java&#45;keyword">implements</span> bookstore.BookStore &#123;
	void buyBook(Book b) &#123;
		// logic
	&#125;
&#125;</pre></div><p class="paragraph"/>This latter technique is arguably cleaner, as the Java side only has a reference to the interface and not to the implementation class. Either way, the goal of this exercise to enable Java to statically resolve the class (or interface) to use, at compile time. Now that this is done you can create a Java class within the <code>src/java</code> package, and provide a setter that uses the type and the name of the bean in Spring:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> bookstore;
// note: <span class="java&#45;keyword">this</span> is Java class
<span class="java&#45;keyword">public</span> class BookConsumer &#123;
	<span class="java&#45;keyword">private</span> BookStore store;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> void setBookStore(BookStore storeInstance) &#123;
		<span class="java&#45;keyword">this</span>.store = storeInstance;
	&#125;	
	&#8230;
&#125;</pre></div><p class="paragraph"/>Once this is done you can configure the Java class as a Spring bean in <code>grails-app/conf/spring/resources.xml</code> (For more information one this see the section on <a href="../guide/single.html#14. Grails and Spring" class="guide">Grails and Spring</a>):<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;bean id=<span class="xml&#45;quote">"bookConsumer"</span> class=<span class="xml&#45;quote">"bookstore.BookConsumer"</span>&#62;</span>
	<span class="xml&#45;tag">&#60;property name=<span class="xml&#45;quote">"bookStore"</span> ref=<span class="xml&#45;quote">"bookService"</span> /&#62;</span>
<span class="xml&#45;tag">&#60;/bean&#62;</span></pre></div><p class="paragraph"/>
	</body>
</html>