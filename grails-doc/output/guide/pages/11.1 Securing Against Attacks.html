<html>
     <head>
     	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
     	<title>11.1 Securing Against Attacks</title>
     	<link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8">
     </head>
	<body class="body">
		<h4>SQL injection</h4><p class="paragraph"/>Hibernate, which is the technology underlying GORM domain classes, automatically escapes data when committing to database so this is not an issue. However it is still possible to write bad dynamic HQL code that uses unchecked request parameters. For example doing the following is vulnerable to HQL injection attacks:<p class="paragraph"/><div class="code"><pre>def vulnerable = &#123;
	def books = Book.find(<span class="java&#45;quote">"from Book as b where b.title ='"</span> + params.title + <span class="java&#45;quote">"'"</span>)
&#125;</pre></div><p class="paragraph"/>Do <strong class="bold">not</strong> do this. If you need to pass in parameters use named or positional parameters instead:<p class="paragraph"/><div class="code"><pre>def safe = &#123;
	def books = Book.find(<span class="java&#45;quote">"from Book as b where b.title =?"</span>, &#91;params.title&#93;)
&#125;</pre></div><p class="paragraph"/>
<h4>Phishing</h4><p class="paragraph"/>This really a public relations issue in terms of avoiding hijacking of your branding and a declared communication policy with your customers. Customers need to know how to identify bonafide emails received.<p class="paragraph"/><h4>XSS - cross-site scripting injection</h4><p class="paragraph"/>It is important that your application verifies as much as possible that incoming requests were originated from your application and not from another site. Ticketing and page flow systems can help this and Grails' support for <a href="http://opensource.atlassian.com/confluence/spring/display/WEBFLOW" target="blank">Spring Web Flow</a> includes security like this by default.<p class="paragraph"/>It is also important to ensure that all data values rendered into views are escaped correctly. For example when rendering to HTML or XHTML you must call <a href="../guide/single.html#11.2 Encoding and Decoding Objects" class="guide">encodeAsHTML</a> on every object to ensure that people cannot maliciously inject JavaScript or other HTML into data or tags viewed by others. Grails supplies several <a href="../guide/single.html#11.2 Encoding and Decoding Objects" class="guide">Dynamic Encoding Methods</a> for this purpose and if your output escaping format is not supported you can easily write your own codec.<p class="paragraph"/>You must also avoid the use of request parameters or data fields for determining the next URL to redirect the user to. If you use a <code>successURL</code> parameter for example to determine where to redirect a user to after a successful login, attackers can imitate your login procedure using your own site, and then redirect the user back to their own site once logged in, potentially allowing JS code to then exploit the logged-in account on the site.<p class="paragraph"/><h4>HTML/URL injection</h4><p class="paragraph"/>This is where bad data is supplied such that when it is later used to create a link in a page, clicking it will not cause the expected behaviour, and may redirect to another site or alter request parameters.<p class="paragraph"/>HTML/URL injection is easily handled with the <a href="../guide/single.html#11.2 Encoding and Decoding Objects" class="guide">codecs</a> supplied by Grails, and the tag libraries supplied by Grails all use <a href="../guide/single.html#11.2 Encoding and Decoding Objects" class="guide">encodeAsURL</a> where appropriate. If you create your own tags that generate URLs you will need to be mindful of doing this too.<p class="paragraph"/><h4>Denial of service</h4><p class="paragraph"/>Load balancers and other appliances are more likely to be useful here, but there are also issues relating to excessive queries for example where a link is created by an attacker to set the maximum value of a result set so that a query could exceed the memory limits of the server or slow the system down. The solution here is to always sanitize request parameters before passing them to dynamic finders or other GORM query methods:<p class="paragraph"/><div class="code"><pre>def safeMax = <span class="java&#45;object">Math</span>.max(params.max?.toInteger(), 100) // never let more than 100 results be returned
<span class="java&#45;keyword">return</span> Book.list(max:safeMax)</pre></div><p class="paragraph"/><h4>Guessable IDs</h4><p class="paragraph"/>Many applications use the last part of the URL as an "id" of some object to retrieve from GORM or elsewhere. Especially in the case of GORM these are easily guessable as they are typically sequential integers.<p class="paragraph"/>Therefore you must assert that the requesting user is allowed to view the object with the requested id before returning the response to the user.<p class="paragraph"/>Not doing this is "security through obscurity" which is inevitably breached, just like having a default password of "letmein" and so on.<p class="paragraph"/>You must assume that every unprotected URL is publicly accessible one way or another.
	</body>
</html>