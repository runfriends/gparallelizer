<html>
     <head>
     	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
     	<title>5.5.2.10 Custom Hibernate Types</title>
     	<link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8">
     </head>
	<body class="body">
		You saw in an earlier section that you can use composition (via the <code>embedded</code> property) to break a table into multiple objects. You can achieve a similar effect via Hibernate's custom user types. These are not domain classes themselves, but plain Java or Groovy classes with associated. Each of these types also has a corresponding "meta-type" class that implements <a href="http://www.hibernate.org/hib_docs/v3/api/org/hibernate/usertype/UserType.html" class="api">org.hibernate.usertype.UserType</a>.<p class="paragraph"/>The <a href="http://www.hibernate.org/hib_docs/v3/reference/en/html/mapping.html#mapping-types-custom" target="blank">Hibernate reference manual</a> has some information on custom types, but here we will focus on how to map them in Grails. Let's start by taking a look at a simple domain class that uses an old-fashioned (pre-Java 1.5) type-safe enum class:<p class="paragraph"/><div class="code"><pre>class Book &#123;
  <span class="java&#45;object">String</span> title
  <span class="java&#45;object">String</span> author
  Rating rating<p class="paragraph"/>  <span class="java&#45;keyword">static</span> mapping = &#123;
      rating type: RatingUserType
  &#125;
&#125;</pre></div><p class="paragraph"/>All we have done is declare the <code>rating</code> field the enum type and set the property's type in the custom mapping to the corresponding <code>UserType</code> implementation. That's all you have to do to start using your custom type. If you want, you can also use the other column settings such as "column" to change the column name and "index" to add it to an index.<p class="paragraph"/>Custom types aren't limited to just a single column - they can be mapped to as many columns as you want. In such cases you need to explicitly define in the mapping what columns to use, since Hibernate can only use the property name for a single column. Fortunately, Grails allows you to map multiple columns to a property using this syntax:<p class="paragraph"/><div class="code"><pre>class Book &#123;
  <span class="java&#45;object">String</span> title
  Name author
  Rating rating<p class="paragraph"/>  <span class="java&#45;keyword">static</span> mapping = &#123;
      name type: NameUserType, &#123;
          column name: <span class="java&#45;quote">"first_name"</span>
          column name: <span class="java&#45;quote">"last_name"</span>
      &#125;
      rating type: RatingUserType
  &#125;
&#125;</pre></div><p class="paragraph"/>The above example will create "first_name" and "last_name" columns for the <code>author</code> property. You'll be pleased to know that you can also use some of the normal column/property mapping attributes in the column definitions. For example:<p class="paragraph"/><div class="code"><pre>column name: <span class="java&#45;quote">"first_name"</span>, index: <span class="java&#45;quote">"my_idx"</span>, unique: <span class="java&#45;keyword">true</span></pre></div><p class="paragraph"/>The column definitions do <em class="italic">not</em> support the following attributes: <code>type</code>, <code>cascade</code>, <code>lazy</code>, <code>cache</code>, and <code>joinTable</code>.<p class="paragraph"/>One thing to bear in mind with custom types is that they define the <em class="italic">SQL types</em> for the corresponding database columns. That helps take the burden of configuring them yourself, but what happens if you have a legacy database that uses a different SQL type for one of the columns? In that case, you need to override column's SQL type using the <code>sqlType</code> attribute:<p class="paragraph"/><div class="code"><pre>class Book &#123;
  <span class="java&#45;object">String</span> title
  Name author
  Rating rating<p class="paragraph"/>  <span class="java&#45;keyword">static</span> mapping = &#123;
      name type: NameUserType, &#123;
          column name: <span class="java&#45;quote">"first_name"</span>, sqlType: <span class="java&#45;quote">"text"</span>
          column name: <span class="java&#45;quote">"last_name"</span>, sqlType: <span class="java&#45;quote">"text"</span>
      &#125;
      rating type: RatingUserType, sqlType: <span class="java&#45;quote">"text"</span>
  &#125;
&#125;</pre></div><p class="paragraph"/>Mind you, the SQL type you specify needs to still work with the custom type. So overriding a default of "varchar" with "text" is fine, but overriding "text" with "yes_no" isn't going to work.

	</body>
</html>