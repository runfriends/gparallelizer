<html>
     <head>
     	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
     	<title>12.10 Understanding Plug-in Load Order</title>
     	<link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8">
     </head>
	<body class="body">
		<h4>Controlling Plug-in Dependencies</h4><p class="paragraph"/>Plug-ins often depend on the presence of other plugins and can also adapt depending on the presence of others. To cover this, a plugin can define two properties. The first is called <code>dependsOn</code>. For example, take a look at this snippet from the Grails Hibernate plugin:<p class="paragraph"/><div class="code"><pre>class HibernateGrailsPlugin &#123;
	def version = 1.0
	def dependsOn = &#91;dataSource:1.0,
	                 domainClass:1.0,
	                 i18n:1.0,
	                 core: 1.0&#93;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>As the above example demonstrates the Hibernate plugin is dependent on the presence of 4 plugins: The <code>dataSource</code> plugin, The <code>domainClass</code> plugin, the <code>i18n</code> plugin and the <code>core</code> plugin.<p class="paragraph"/>Essentially the dependencies will be loaded first and then the Hibernate plugin. If all dependencies do not load, then the plugin will not load.<p class="paragraph"/>The <code>dependsOn</code> property also supports a mini expression language for specifying version ranges. A few examples of the syntax can be seen below:<p class="paragraph"/><div class="code"><pre>def dependsOn = &#91;foo:<span class="java&#45;quote">"&#42; &#62; 1.0"</span>&#93;
def dependsOn = &#91;foo:<span class="java&#45;quote">"1.0 &#62; 1.1"</span>&#93;
def dependsOn = &#91;foo:<span class="java&#45;quote">"1.0 &#62; &#42;"</span>&#93;</pre></div><p class="paragraph"/>When the wildcard * character is used it denotes "any" version. The expression syntax also excludes any suffixes such as -BETA, -ALPHA etc. so for example the expression "1.0 &#62; 1.1" would match any of the following versions:
<ul class="star">
<li>1.1</li>
<li>1.0</li>
<li>1.0.1</li>
<li>1.0.3-SNAPSHOT</li>
<li>1.1-BETA2</li>
</ul><p class="paragraph"/><h4>Controlling Load Order </h4><p class="paragraph"/>Using <code>dependsOn</code> establishes a "hard" dependency in that if the dependency is not resolved, the plugin will give up and won't load.  It is possible though to have a "weaker" dependency using the <code>loadAfter</code> property:<p class="paragraph"/><div class="code"><pre>def loadAfter = &#91;'controllers'&#93;</pre></div><p class="paragraph"/>Here the plugin will be loaded after the <code>controllers</code> plugin if it exists, otherwise it will just be loaded. The plugin can then adapt to the presence of the other plugin, for example the Hibernate plugin has this code in the <code>doWithSpring</code> closure:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">if</span>(manager?.hasGrailsPlugin(<span class="java&#45;quote">"controllers"</span>)) &#123;
	openSessionInViewInterceptor(OpenSessionInViewInterceptor) &#123;
        	flushMode = HibernateAccessor.FLUSH_MANUAL
	        sessionFactory = sessionFactory
	&#125;
        grailsUrlHandlerMapping.interceptors &#60;&#60; openSessionInViewInterceptor
  &#125;</pre></div><p class="paragraph"/>Here the Hibernate plugin will only register an <code>OpenSessionInViewInterceptor</code> if the <code>controllers</code> plugin has been loaded. The manager variable is an instance of the api:org.codehaus.groovy.grails.plugins.GrailsPluginManager interface and it provides methods to interact with other plugins and the <code>GrailsPluginManager</code> itself from any plugin.
	</body>
</html>