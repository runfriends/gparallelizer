<html>
     <head>
     	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
     	<title>11. Security</title>
     	<link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8">
     </head>
	<body class="body">
		<h1><a name="11. Security">11. Security</a></h1>Grails is no more or less secure than Java Servlets. However, Java servlets (and hence Grails) are extremely secure and largely immune to common buffer overrun and malformed URL exploits due to the nature of the Java Virtual Machine underpinning the code.<p class="paragraph"/>Web security problems typically occur due to developer naivety or mistakes, and there is a little Grails can do to avoid common mistakes and make writing secure applications easier to write.<p class="paragraph"/><h4>What Grails Automatically Does</h4><p class="paragraph"/>Grails has a few built in safety mechanisms by default.
<ol>
<li>All standard database access via <a href="../guide/single.html#5. Object Relational Mapping (GORM)" class="guide">GORM</a> domain objects is automatically SQL escaped to prevent SQL injection attacks</li>
<li>The default <a href="../guide/single.html#16. Scaffolding" class="guide">scaffolding</a> templates HTML escape all data fields when displayed</li>
<li>Grails link creating tags (<a href="../ref/Tags/link.html" class="tags">link</a>, <a href="../ref/Tags/form.html" class="tags">form</a>, <a href="../ref/Tags/createLink.html" class="tags">createLink</a>, <a href="../ref/Tags/createLinkTo.html" class="tags">createLinkTo</a> and others) all use appropriate escaping mechanisms to prevent code injection</li>
<li>Grails provides <a href="../guide/single.html#11.2 Encoding and Decoding Objects" class="guide">codecs</a> to allow you to trivially escape data when rendered as HTML, JavaScript and URLs to prevent injection attacks here.</li>
</ol><p class="paragraph"/><h2><a name="11.1 Securing Against Attacks">11.1 Securing Against Attacks</a></h2><h4>SQL injection</h4><p class="paragraph"/>Hibernate, which is the technology underlying GORM domain classes, automatically escapes data when committing to database so this is not an issue. However it is still possible to write bad dynamic HQL code that uses unchecked request parameters. For example doing the following is vulnerable to HQL injection attacks:<p class="paragraph"/><div class="code"><pre>def vulnerable = &#123;
	def books = Book.find(<span class="java&#45;quote">"from Book as b where b.title ='"</span> + params.title + <span class="java&#45;quote">"'"</span>)
&#125;</pre></div><p class="paragraph"/>Do <strong class="bold">not</strong> do this. If you need to pass in parameters use named or positional parameters instead:<p class="paragraph"/><div class="code"><pre>def safe = &#123;
	def books = Book.find(<span class="java&#45;quote">"from Book as b where b.title =?"</span>, &#91;params.title&#93;)
&#125;</pre></div><p class="paragraph"/>
<h4>Phishing</h4><p class="paragraph"/>This really a public relations issue in terms of avoiding hijacking of your branding and a declared communication policy with your customers. Customers need to know how to identify bonafide emails received.<p class="paragraph"/><h4>XSS - cross-site scripting injection</h4><p class="paragraph"/>It is important that your application verifies as much as possible that incoming requests were originated from your application and not from another site. Ticketing and page flow systems can help this and Grails' support for <a href="http://opensource.atlassian.com/confluence/spring/display/WEBFLOW" target="blank">Spring Web Flow</a> includes security like this by default.<p class="paragraph"/>It is also important to ensure that all data values rendered into views are escaped correctly. For example when rendering to HTML or XHTML you must call <a href="../guide/single.html#11.2 Encoding and Decoding Objects" class="guide">encodeAsHTML</a> on every object to ensure that people cannot maliciously inject JavaScript or other HTML into data or tags viewed by others. Grails supplies several <a href="../guide/single.html#11.2 Encoding and Decoding Objects" class="guide">Dynamic Encoding Methods</a> for this purpose and if your output escaping format is not supported you can easily write your own codec.<p class="paragraph"/>You must also avoid the use of request parameters or data fields for determining the next URL to redirect the user to. If you use a <code>successURL</code> parameter for example to determine where to redirect a user to after a successful login, attackers can imitate your login procedure using your own site, and then redirect the user back to their own site once logged in, potentially allowing JS code to then exploit the logged-in account on the site.<p class="paragraph"/><h4>HTML/URL injection</h4><p class="paragraph"/>This is where bad data is supplied such that when it is later used to create a link in a page, clicking it will not cause the expected behaviour, and may redirect to another site or alter request parameters.<p class="paragraph"/>HTML/URL injection is easily handled with the <a href="../guide/single.html#11.2 Encoding and Decoding Objects" class="guide">codecs</a> supplied by Grails, and the tag libraries supplied by Grails all use <a href="../guide/single.html#11.2 Encoding and Decoding Objects" class="guide">encodeAsURL</a> where appropriate. If you create your own tags that generate URLs you will need to be mindful of doing this too.<p class="paragraph"/><h4>Denial of service</h4><p class="paragraph"/>Load balancers and other appliances are more likely to be useful here, but there are also issues relating to excessive queries for example where a link is created by an attacker to set the maximum value of a result set so that a query could exceed the memory limits of the server or slow the system down. The solution here is to always sanitize request parameters before passing them to dynamic finders or other GORM query methods:<p class="paragraph"/><div class="code"><pre>def safeMax = <span class="java&#45;object">Math</span>.max(params.max?.toInteger(), 100) // never let more than 100 results be returned
<span class="java&#45;keyword">return</span> Book.list(max:safeMax)</pre></div><p class="paragraph"/><h4>Guessable IDs</h4><p class="paragraph"/>Many applications use the last part of the URL as an "id" of some object to retrieve from GORM or elsewhere. Especially in the case of GORM these are easily guessable as they are typically sequential integers.<p class="paragraph"/>Therefore you must assert that the requesting user is allowed to view the object with the requested id before returning the response to the user.<p class="paragraph"/>Not doing this is "security through obscurity" which is inevitably breached, just like having a default password of "letmein" and so on.<p class="paragraph"/>You must assume that every unprotected URL is publicly accessible one way or another.<h2><a name="11.2 Encoding and Decoding Objects">11.2 Encoding and Decoding Objects</a></h2>Grails supports the concept of dynamic encode/decode methods.  A set of standard codecs are bundled with Grails.  Grails also supports a simple mechanism for developers to contribute their own codecs that will be recognized at runtime.<p class="paragraph"/><h4>Codec Classes</h4><p class="paragraph"/>A Grails codec class is a class that may contain an encode closure, a decode closure or both.  When a Grails application starts up the Grails framework will dynamically load codecs from the <code>grails-app/utils/</code> directory.<p class="paragraph"/>The framework will look under <code>grails-app/utils/</code> for class names that end with the convention <code>Codec</code>.  For example one of the standard codecs that ship with Grails is <code>HTMLCodec</code>.<p class="paragraph"/>If a codec contains an <code>encode</code> property assigned a block of code Grails will create a dynamic <code>encode</code> method and add that method to the Object class with a name representing the codec that defined the encode closure.  For example, the <code>HTMLCodec</code> class defines an <code>encode</code> block so Grails will attach that closure to the <code>Object</code> class with the name <code>encodeAsHTML</code>.<p class="paragraph"/>The <code>HTMLCodec</code> and <code>URLCodec</code> classes also define a <code>decode</code> block so Grails will attach those with the names <code>decodeHTML</code> and <code>decodeURL</code>. Dynamic codec methods may be invoked from anywhere in a Grails application. For example, consider a case where a report contains a property called 'description' and that description may contain special characters that need to be escaped to be presented in an HTML document.  One way to deal with that in a GSP is to encode the description property using the dynamic encode method as shown below:<p class="paragraph"/><div class="code"><pre>$&#123;report.description.encodeAsHTML()&#125;</pre></div><p class="paragraph"/>Decoding is performed using <code>value.decodeHTML()</code> syntax.<p class="paragraph"/><h4>Standard Codecs</h4><p class="paragraph"/><strong class="bold">HTMLCodec</strong><p class="paragraph"/>This codec perfoms HTML escaping and unescaping, so that values you provide can be rendered safely in an HTML page without creating any HTML tags or damaging the page layout. For example, given a value "Don't you know that 2 &#62; 1?" you wouldn't be able to show this safely within an HTML page because the &#62; will look like it closes a tag, which is especially bad if you render this data within an attribute, such as the value attribute of an input field.<p class="paragraph"/>Example of usage:<p class="paragraph"/><div class="code"><pre>&#60;input name=<span class="java&#45;quote">"comment.message"</span> value=<span class="java&#45;quote">"$&#123;comment.message.encodeAsHTML()&#125;"</span>/&#62;</pre></div><p class="paragraph"/>
<blockquote class="note">
Note that the HTML encoding does not re-encode apostrophe/single quote so you must use double quotes on attribute values to avoid text with apostrophes messing up your page.
</blockquote><p class="paragraph"/><strong class="bold">URLCodec</strong><p class="paragraph"/>URL encoding is required when creating URLs in links or form actions, or any time data may be used to create a URL. It prevents illegal characters getting into the URL to change its meaning, for example a "Apple &#38; Blackberry" is not going to work well as a parameter in a GET request as the ampersand will break the parsing of parameters.<p class="paragraph"/>Example of usage:<p class="paragraph"/><div class="code"><pre>&#60;a href=<span class="java&#45;quote">"/mycontroller/find?searchKey=$&#123;lastSearch.encodeAsURL()&#125;"</span>&#62;Repeat last search&#60;/a&#62;</pre></div><p class="paragraph"/>
<strong class="bold">Base64Codec</strong><p class="paragraph"/>Performs Base64 encode/decode functions. Example of usage:<p class="paragraph"/><div class="code"><pre>Your registration code is: $&#123;user.registrationCode.encodeAsBase64()&#125;</pre></div><p class="paragraph"/>
<strong class="bold">JavaScriptCodec</strong><p class="paragraph"/>Will escape Strings so they can be used as valid JavaSctipt strings. Example of usage:<p class="paragraph"/><div class="code"><pre>Element.update('$&#123;elementId&#125;', '$&#123;render(template: <span class="java&#45;quote">"/common/message"</span>).encodeAsJavaScript()&#125;')</pre></div><p class="paragraph"/>
<strong class="bold">HexCodec</strong><p class="paragraph"/>Will encode byte arrays or lists of integers to lowercase hexadecimal strings, and can decode hexadecimal strings into byte arrays. Example of usage:<p class="paragraph"/><div class="code"><pre>Selected colour: &#35;$&#123;&#91;255,127,255&#93;.encodeAsHex()&#125;</pre></div><p class="paragraph"/>
<strong class="bold">MD5Codec</strong><p class="paragraph"/>Will use the MD5 algorithm to digest byte arrays or lists of integers, or the bytes of a string (in default system encoding), as a lowercase hexadecimal string. Example of usage:<p class="paragraph"/><div class="code"><pre>Your API Key: $&#123;user.uniqueID.encodeAsMD5()&#125;</pre></div><p class="paragraph"/><strong class="bold">MD5BytesCodec</strong><p class="paragraph"/>Will use the MD5 algorithm to digest byte arrays or lists of integers, or the bytes of a string (in default system encoding), as a byte array. Example of usage:<p class="paragraph"/><div class="code"><pre><span class="java&#45;object">byte</span>&#91;&#93; passwordHash = params.password.encodeAsMD5Bytes()</pre></div><p class="paragraph"/>
<strong class="bold">SHA1Codec</strong><p class="paragraph"/>Will use the SHA1 algorithm to digest byte arrays or lists of integers, or the bytes of a string (in default system encoding), as a lowercase hexadecimal string. Example of usage:<p class="paragraph"/><div class="code"><pre>Your API Key: $&#123;user.uniqueID.encodeAsSHA1()&#125;</pre></div><p class="paragraph"/><strong class="bold">SHA1BytesCodec</strong><p class="paragraph"/>Will use the SHA1 algorithm to digest byte arrays or lists of integers, or the bytes of a string (in default system encoding), as a byte array. Example of usage:<p class="paragraph"/><div class="code"><pre><span class="java&#45;object">byte</span>&#91;&#93; passwordHash = params.password.encodeAsSHA1Bytes()</pre></div><p class="paragraph"/>
<strong class="bold">SHA256Codec</strong><p class="paragraph"/>Will use the SHA256 algorithm to digest byte arrays or lists of integers, or the bytes of a string (in default system encoding), as a lowercase hexadecimal string. Example of usage:<p class="paragraph"/><div class="code"><pre>Your API Key: $&#123;user.uniqueID.encodeAsSHA256()&#125;</pre></div><p class="paragraph"/><strong class="bold">SHA256BytesCodec</strong><p class="paragraph"/>Will use the SHA256 algorithm to digest byte arrays or lists of integers, or the bytes of a string (in default system encoding), as a byte array. Example of usage:<p class="paragraph"/><div class="code"><pre><span class="java&#45;object">byte</span>&#91;&#93; passwordHash = params.password.encodeAsSHA256Bytes()</pre></div><p class="paragraph"/>
<h4>Custom Codecs</h4><p class="paragraph"/>Applications may define their own codecs and Grails will load them along with the standard codecs. A custom codec class must be defined in the <code>grails-app/utils/</code> directory and the class name must end with <code>Codec</code>. The codec may contain a <code>static</code> <code>encode</code> block, a <code>static</code> <code>decode</code> block or both. The block should expect a single argument which will be the object that the dynamic method was invoked on. For Example:<p class="paragraph"/><div class="code"><pre>class PigLatinCodec &#123;
  <span class="java&#45;keyword">static</span> encode = &#123; str &#45;&#62;
    // convert the string to piglatin and <span class="java&#45;keyword">return</span> the result
  &#125;
&#125;</pre></div><p class="paragraph"/>
With the above codec in place an application could do something like this:<p class="paragraph"/><div class="code"><pre>$&#123;lastName.encodeAsPigLatin()&#125;</pre></div><p class="paragraph"/><h2><a name="11.3 Authentication">11.3 Authentication</a></h2>Although there is no current default mechanism for authentication as it is possible to implement authentication in literally thousands of different ways. It is however, trivial to implement a simple authentication mechanism using either <a href="../guide/single.html#6.1.5 Controller Interceptors" class="guide">interceptors</a> or <a href="../guide/single.html#6.6 Filters" class="guide">filters</a>.<p class="paragraph"/>Filters allow you to apply authentication across all controllers or across a URI space. For example you can create a new set of filters in a class called <code>grails-app/conf/SecurityFilters.groovy</code>:<p class="paragraph"/><div class="code"><pre>class SecurityFilters &#123;
   def filters = &#123;
       loginCheck(controller:'&#42;', action:'&#42;') &#123;
           before = &#123;
              <span class="java&#45;keyword">if</span>(!session.user &#38;&#38; actionName != <span class="java&#45;quote">"login"</span>) &#123;
                  redirect(controller:<span class="java&#45;quote">"user"</span>,action:<span class="java&#45;quote">"login"</span>)
                  <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">false</span>					
	           &#125;
           &#125;<p class="paragraph"/>       &#125;
   &#125;
&#125;</pre></div><p class="paragraph"/>Here the <code>loginCheck</code> filter will intercept execution <em class="italic">before</em> an action executed and if their is no user in the session and the action being executed is not the <code>login</code> action then redirect to the <code>login</code> action.<p class="paragraph"/>The <code>login</code> action itself is trivial too:<p class="paragraph"/><div class="code"><pre>def login = &#123;
	<span class="java&#45;keyword">if</span>(request.get) render(view:<span class="java&#45;quote">"login"</span>)
	<span class="java&#45;keyword">else</span> &#123;
		def u = User.findByLogin(params.login)
		<span class="java&#45;keyword">if</span>(u) &#123;
			<span class="java&#45;keyword">if</span>(u.password == params.password) &#123;
				session.user = u
				redirect(action:<span class="java&#45;quote">"home"</span>)
			&#125;
			<span class="java&#45;keyword">else</span> &#123;
				render(view:<span class="java&#45;quote">"login"</span>, model:&#91;message:<span class="java&#45;quote">"Password incorrect"</span>&#93;)							
			&#125;
		&#125;
		<span class="java&#45;keyword">else</span> &#123;
			render(view:<span class="java&#45;quote">"login"</span>, model:&#91;message:<span class="java&#45;quote">"User not found"</span>&#93;)			
		&#125;
	&#125;
&#125;</pre></div><h2><a name="11.4 Security Plug-ins">11.4 Security Plug-ins</a></h2>If you need more advanced functionality beyond simple authentication such as authorization, roles etc. then you may want to consider using one of the available security plug-ins.<h2><a name="11.4.1 Acegi">11.4.1 Acegi</a></h2>The Acegi Plug-in is built on the <a href="http://www.acegisecurity.org/" target="blank">Spring Acegi</a> project which provides a flexible, extensible framework for building all sorts of authentication and authorization schemes.<p class="paragraph"/>The Acegi plug-in requires you to specify a mapping between URIs and roles and provides a default domain model to model people, authorities and request maps. See the <a href="http://grails.org/AcegiSecurity+Plugin" target="blank">documentation on the wiki</a> for more information.<h2><a name="11.4.2 JSecurity">11.4.2 JSecurity</a></h2><a href="http://www.jsecurity.org/" target="blank">JSecurity</a> is another Java POJO oriented security framework that again provides a default domain model that models realms, users, roles and permissions. With JSecurity you have to extends a controller base called called <code>JsecAuthBase</code> in each controller you want secured and then provide an <code>accessControl</code> block to setup the roles. An example below:<p class="paragraph"/><div class="code"><pre>class ExampleController <span class="java&#45;keyword">extends</span> JsecAuthBase &#123;
    <span class="java&#45;keyword">static</span> accessControl = &#123;
        // All actions require the 'Observer' role.
        role(name: 'Observer')<p class="paragraph"/>        // The 'edit' action requires the 'Administrator' role.
        role(name: 'Administrator', action: 'edit')<p class="paragraph"/>        // Alternatively, several actions can be specified.
        role(name: 'Administrator', only: &#91; 'create', 'edit', 'save', 'update' &#93;)
    &#125;<p class="paragraph"/>    &#8230;
&#125;</pre></div><p class="paragraph"/>For more information on the JSecurity plug-in refer to the <a href="http://grails.org/JSecurity+Plugin+-+Quick+Start" target="blank">JSecurity Quick Start</a>.
	</body>
</html>