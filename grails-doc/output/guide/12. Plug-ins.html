<html>
     <head>
     	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
     	<title>12. Plug-ins</title>
     	<link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8">
     </head>
	<body class="body">
		<h1><a name="12. Plug-ins">12. Plug-ins</a></h1>Grails provides a number of extension points that allow you to extend anything from the command line interface to the runtime configuration engine. The following sections detail how to go about it.<h2><a name="12.1 Creating and Installing Plug-ins">12.1 Creating and Installing Plug-ins</a></h2><h4>Creating Plug-ins</h4><p class="paragraph"/>Creating a Grails plugin is a simple matter of running the command:<p class="paragraph"/><div class="code"><pre>grails create&#45;plugin &#91;PLUGIN NAME&#93;</pre></div><p class="paragraph"/>This will create a plugin project for the name you specify. Say for example you run <code>grails create-plugin example</code>. This would create a new plugin project called <code>example</code>.<p class="paragraph"/>The structure of a Grails plugin is exactly the same as a regular Grails project's directory structure, except that in the root of the plugin directory you will find a plugin Groovy file called the "plug-in descriptor".<p class="paragraph"/>Being a regular Grails project has a number of benefits in that you can immediately get going testing your plug-in by running:<p class="paragraph"/><div class="code"><pre>grails run&#45;app</pre></div><p class="paragraph"/>The plugin descriptor itself ends with the convention <code>GrailsPlugin</code> and is found in the root of the plugin project. For example:<p class="paragraph"/><div class="code"><pre>class ExampleGrailsPlugin &#123;
   def version = 0.1<p class="paragraph"/>   &#8230;
&#125;</pre></div><p class="paragraph"/>All plugins must have this class in the root of their directory structure to be valid. The plugin class defines the version of the plugin and optionally various hooks into plugin extension points (covered shortly).<p class="paragraph"/>You can also provide additional information about your plugin using several special properties:
<ul class="star">
<li><code>title</code> - short one sentence description of your plugin</li>
<li><code>version</code> - The version of your problem. Valid versions are for example "0.1", "0.2-SNAPSHOT", "0.1.4" etc.</li>
<li><code>grailsVersion</code> - The version of version range of Grails that the plugin supports. eg. "1.1 &#62; *"</li>
<li><code>author</code> - plug-in author's name</li>
<li><code>authorEmail</code> - plug-in author's contact e-mail</li>
<li><code>description</code> - full multi-line description of plug-in's features</li>
<li><code>documentation</code> - URL where plug-in's documentation can be found</li>
</ul><p class="paragraph"/>Here is an example from <a href="http://grails.org/Quartz+plugin:" target="blank">Quartz Grails plugin</a><p class="paragraph"/><div class="code"><pre>class QuartzGrailsPlugin &#123;
    def version = <span class="java&#45;quote">"0.1"</span>
	def grailsVersion = <span class="java&#45;quote">"1.1 &#62; &#42;"</span>
    def author = <span class="java&#45;quote">"Sergey Nebolsin"</span>
    def authorEmail = <span class="java&#45;quote">"nebolsin@gmail.com"</span>
    def title = <span class="java&#45;quote">"This plugin adds Quartz job scheduling features to Grails application."</span>
    def description = '''
Quartz plugin allows your Grails application to schedule jobs to be
executed using a specified interval or cron expression. The underlying
system uses the Quartz Enterprise Job Scheduler configured via Spring,
but is made simpler by the coding by convention paradigm.
'''
    def documentation = <span class="java&#45;quote">"http://grails.org/Quartz+plugin"</span><p class="paragraph"/>   &#8230;
&#125;</pre></div><p class="paragraph"/><h4>Installing &#38; Distributing Plugins</h4><p class="paragraph"/>To distribute a plugin you need to navigate to its root directory in a terminal window and then type:<p class="paragraph"/><div class="code"><pre>grails <span class="java&#45;keyword">package</span>&#45;plugin</pre></div><p class="paragraph"/>This will create a zip file of the plugin starting with <code>grails-</code> then the plugin name and version. For example with the example plug-in created earlier this would be <code>grails-example-0.1.zip</code>. The <code>package-plugin</code> command will also generate <code>plugin.xml</code> file which contains machine-readable information about plugin's name, version, author, and so on.<p class="paragraph"/>Once you have a plugin distribution file you can navigate to a Grails project and type:<p class="paragraph"/><div class="code"><pre>grails install&#45;plugin /path/to/plugin/grails&#45;example&#45;0.1.zip</pre></div><p class="paragraph"/>If the plugin is hosted on a remote HTTP server you can also do:<p class="paragraph"/><div class="code"><pre>grails install&#45;plugin http://myserver.com/plugins/grails&#45;example&#45;0.1.zip</pre></div><p class="paragraph"/><h4>Notes on excluded Artefacts</h4><p class="paragraph"/>Although the <a href="../ref/Command Line/create-plugin.html" class="commandLine">create-plugin</a> command creates certain files for you so that the plug-in can be run as a Grails application, not all of these files are included when packaging a plug-in. The following is a list of artefacts created, but not included by <a href="../ref/Command Line/package-plugin.html" class="commandLine">package-plugin</a>:
<ul class="star">
<li><code>grails-app/conf/DataSource.groovy</code></li>
<li><code>grails-app/conf/UrlMappings.groovy</code></li>
<li><code>grails-app/conf/DataSource.groovy</code></li>
<li><code>build.xml</code></li>
<li>Everything within <code>/web-app/WEB-INF</code></li>
</ul><p class="paragraph"/>If you need artefacts within <code>WEB-INF</code> it is recommended you use the <code>_Install.groovy</code> script (covered later), which is executed when a plug-in is installed, to provide such artefacts. In addition, although <code>UrlMappings.groovy</code> is excluded you are allowed to include a <code>UrlMappings</code> definition with a different name, such as <code>FooUrlMappings.groovy</code>.<p class="paragraph"/><p class="paragraph"/><h2><a name="12.2 Plugin Repositories">12.2 Plugin Repositories</a></h2><h4>Distributing Plugins in Grails Plugins Repository</h4><p class="paragraph"/>The preferred way of plugin distributing is to publish it under Grails Plugins Repository. This will make your plugin visible to the <a href="../ref/Command Line/list-plugins.html" class="commandLine">list-plugins</a> command:<p class="paragraph"/><div class="code"><pre>grails list&#45;plugins</pre></div><p class="paragraph"/>Which lists all plugins in the Grails Plugin repository and also the <a href="../ref/Command Line/plugin-info.html" class="commandLine">plugin-info</a> command:<p class="paragraph"/><div class="code"><pre>grails plugin&#45;info &#91;plugin&#45;name&#93;</pre></div><p class="paragraph"/>Which outputs more information based on the meta info entered into the plug-in descriptor.<p class="paragraph"/><blockquote class="note">
If you have created a Grails plug-in and want it to be hosted in the central repository take a look at the wiki page <a href="http://grails.org/Creating+Plugins" target="blank"></a>, which details how to go about releasing your plugin in the repository.
</blockquote><p class="paragraph"/>When you have access to the Grails Plug-in repository to release your plugin you simply have to execute the <a href="../ref/Command Line/release-plugin.html" class="commandLine">release-plugin</a> command:<p class="paragraph"/><div class="code"><pre>grails release&#45;plugin</pre></div><p class="paragraph"/>This will automatically commit changes to SVN, do some tagging and make your changes available via the <a href="../ref/Command Line/list-plugins.html" class="commandLine">list-plugins</a> command.<p class="paragraph"/><h4>Configuring Additional Repositories</h4><p class="paragraph"/>By default when you use the <a href="../ref/Command Line/list-plugins.html" class="commandLine">list-plugins</a>, <a href="../ref/Command Line/install-plugin.html" class="commandLine">install-plugin</a> and <a href="../ref/Command Line/release-plugin.html" class="commandLine">release-plugin</a> command they work against the central repository hosted at http://plugins.grails.org.<p class="paragraph"/>However, Grails supports the notion of multiple plugin repositories. To configure multiple repositories you can using the <code>grails-app/conf/BuildConfig.groovy</code> file:<p class="paragraph"/><div class="code"><pre>grails.plugin.repos.discovery.myRepository=<span class="java&#45;quote">"http://svn.codehaus.org/grails/trunk/grails&#45;test&#45;plugin&#45;repo"</span> 
grails.plugin.repos.distribution.myRepository=<span class="java&#45;quote">"https://svn.codehaus.org/grails/trunk/grails&#45;test&#45;plugin&#45;repo"</span></pre></div><p class="paragraph"/>Repositories are split into those used for discovery over HTTP and those used for distribution, typically over HTTPS. You can also provide these settings in the <code>USER_HOME/.grails/settings.groovy</code> file if you prefer to share the same settings across multiple projects.<p class="paragraph"/>Once this is done the <a href="../ref/Command Line/list-plugins.html" class="commandLine">list-plugins</a>, <a href="../ref/Command Line/install-plugin.html" class="commandLine">install-plugin</a> and <a href="../ref/Command Line/plugin-info.html" class="commandLine">plugin-info</a> commands will automatically resolve against the newly configured repository. If you want to list only the plugins from the repository you can use its alias to do so:<p class="paragraph"/><div class="code"><pre>grails list&#45;plugins &#45;repository=myRepository</pre></div><p class="paragraph"/>Additionally, if you want to distribute a plugin within the configured repository you can do so with the <a href="../ref/Command Line/release-plugin.html" class="commandLine">release-plugin</a> command:<p class="paragraph"/><div class="code"><pre>grails release&#45;plugin &#45;repository=myRepository</pre></div><p class="paragraph"/><h4>Secured Plugin Repositories</h4><p class="paragraph"/>By default when using a repository URL starting with the <code>https://</code> protocol, Grails will prompt you for a username and password. If you prefer 
not to get these prompts then you can specify the username and password to use in your <code>~/.grails/settings.groovy</code> file as follows:<p class="paragraph"/><div class="code"><pre>grails.plugin.repos.discovery.myRepo=<span class="java&#45;quote">"https://user01:password01@myserver.com"</span></pre></div><p class="paragraph"/>The format is:<p class="paragraph"/><div class="code"><pre>PROTOCOL://USERNAME:PASSWORD@SERVER</pre></div><p class="paragraph"/>With this set Grails will use the specified username and password rather than prompting you for one.<p class="paragraph"/><h4>Configuring Repository Search Order</h4><p class="paragraph"/>A common use case for having your own plugin repository is when you want to override or provide a modified version of an existing plugin within the central repository.<p class="paragraph"/>However, by default Grails will search repository in a preset order. The repositories it will search are as follows:
<ul class="star">
<li><code>default</code> - The default repository found at <code>http://plugins.grails.org</code></li>
<li><code>core</code> - The repository for plugins provides by the framework (such as the hibernate plugin)</li>
</ul><p class="paragraph"/>If you add an additional repository then Grails will search the repository you have defined last, meaning it is not possible to override a plugin in the central repository unless you change the search order. To change the repository search order you can do the following:<p class="paragraph"/><div class="code"><pre>grails.plugin.repos.resolveOrder=&#91;'myRepository','<span class="java&#45;keyword">default</span>','core'&#93;</pre></div><p class="paragraph"/>In the above case the repository called <code>myRepository</code> will be searched before the default one. In addition, if you remove the built in repositories from the list you can prevent Grails from searching these repositories at all:<p class="paragraph"/><div class="code"><pre>grails.plugin.repos.resolveOrder=&#91;'myRepository'&#93;</pre></div><p class="paragraph"/>This is useful in a circumstance where you don't want Grails to perform any internet lookups when searching for plugins.<h2><a name="12.3 Understanding a Plug-ins Structure">12.3 Understanding a Plug-ins Structure</a></h2>As as mentioned previously, a plugin is merely a regular Grails application with a contained plug-in descriptors. However when installed, the structure of a plugin differs slightly. For example, take a look at this plugin directory structure:<p class="paragraph"/><div class="code"><pre>+ grails&#45;app
     + controllers
     + domain
     + taglib
     etc.
 + lib
 + src
     + java
     + groovy
 + web&#45;app
     + js
     + css</pre></div><p class="paragraph"/>Essentially when a plugin is installed into a project, the contents of the <code>grails-app</code> directory will go into a directory such as <code>plugins/example-1.0/grails-app</code>. They <strong class="bold">will not</strong> be copied into the main source tree. A plugin never interferes with a project's primary source tree.<p class="paragraph"/>However, static resources such as those inside the <code>web-app</code> directory will be copied into the project's web-app directory under a special <code>plugins</code> directory. For example <code>web-app/plugins/example-1.0/js</code>.<p class="paragraph"/>It is therefore the responsibility of the plugin to make sure that it references static resources from the correct place. For example if you were referencing a JavaScript source from a GSP you could use:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:resource dir=<span class="xml&#45;quote">"/plugins/example/js"</span> file=<span class="xml&#45;quote">"mycode.js"</span> /&#62;</span></pre></div><p class="paragraph"/>However this may cause a problem during development as the relative link when installed differs from when you're running the plugin standalone.<p class="paragraph"/>To make this easier there is a special <code>pluginContextPath</code> variable available that changes whether you're executing the plugin standalone or whether you've installed it into an application:<p class="paragraph"/><div class="code"><pre><span class="xml&#45;tag">&#60;g:resource dir=<span class="xml&#45;quote">"$&#123;pluginContextPath&#125;/js"</span> file=<span class="xml&#45;quote">"mycode.js"</span> /&#62;</span></pre></div><p class="paragraph"/>At runtime the <code>pluginContextPath</code> will either evaluate to an empty string or <code>/plugins/example</code> depending on whether the plugin is running standalone or has been installed in an application<p class="paragraph"/>Java &#38; Groovy code that the plugin provides within the lib and <code>src/java</code> and <code>src/groovy</code> directories will be compiled into the main project's <code>web-app/WEB-INF/classes</code> directory so that they are made available at runtime.
<h2><a name="12.4 Providing Basic Artefacts">12.4 Providing Basic Artefacts</a></h2><h4>Adding a new Script</h4><p class="paragraph"/>A plugin can add a new script simply by providing the relevant Gant script within the scripts directory of the plugin:<p class="paragraph"/><div class="code"><pre>+ MyPlugin.groovy
   + scripts     &#60;&#45;&#45; additional scripts here
   + grails&#45;app
        + controllers
        + services
        + etc.
    + lib</pre></div><p class="paragraph"/><h4>Adding a new Controller, Tag Library or Service</h4><p class="paragraph"/>A plugin can add a new controller, tag libraries, service or whatever by simply creating the relevant file within the <code>grails-app</code> tree. Note that when the plugin is installed it will be loaded from where it is installed and not copied into the main application tree.<p class="paragraph"/><div class="code"><pre>+ ExamplePlugin.groovy
   + scripts
   + grails&#45;app
        + controllers  &#60;&#45;&#45; additional controllers here
        + services &#60;&#45;&#45; additional services here
        + etc.  &#60;&#45;&#45; additional XXX here
    + lib</pre></div><p class="paragraph"/><h4>Providing Views, Templates and View resolution</h4><p class="paragraph"/>When a plug-in provides a controller it may also provide default views to be rendered. This is an excellent way to modularize your application through plugins. The way it works is that Grails' view resolution mechanism will first look the view in the application it is installed into and if that fails will attempt to look for the view within the plug-in.<p class="paragraph"/>For example given a <code>AmazonGrailsPlugin</code> plug-n provided controller called <code>BookController</code> if the action being executed is <code>list</code>, Grails will first look for a view called <code>grails-app/views/book/list.gsp</code> then if that fails will look for the same view relative to the plug-in.<p class="paragraph"/>Note however that if the view uses templates that are also provided by the plugin then the following syntax is necessary:<p class="paragraph"/><div class="code"><pre>&#60;g:render template=<span class="java&#45;quote">"fooTemplate"</span> plugin=<span class="java&#45;quote">"amazon"</span>/&#62;</pre></div><p class="paragraph"/>Note the usage of the <code>plugin</code> attribute, which contains the name of the plugin where the template resides. If this is not specified then Grails will look for the template relative to the application.<p class="paragraph"/><h4>Excluded Artefacts</h4><p class="paragraph"/>Note that by default, when packaging a plug-in, Grails will excludes the following files from the packaged plug-in:
<ul class="star">
<li>grails-app/conf/DataSource.groovy</li>
<li>grails-app/conf/UrlMappings.groovy</li>
<li>Everything under web-app/WEB-INF</li>
</ul><p class="paragraph"/>If your plug-in does require files under the <code>web-app/WEB-INF</code> directory it is recommended that you modify the plug-in's <code>scripts/_Install.groovy</code> Gant script to install these artefacts into the target project's directory tree.<p class="paragraph"/>In addition, the default <code>UrlMappings.groovy</code> file is excluded to avoid naming conflicts, however you are free to add a UrlMappings definition under a different name which <strong class="bold">will</strong> be included. For example a file called <code>grails-app/conf/BlogUrlMappings.groovy</code> is fine.<p class="paragraph"/>Additionally the list of includes is extensible via the <code>pluginExcludes</code> property:<p class="paragraph"/><div class="code"><pre>// resources that are excluded from plugin packaging
def pluginExcludes = &#91;
        <span class="java&#45;quote">"grails&#45;app/views/error.gsp"</span>
&#93;</pre></div><p class="paragraph"/>This is useful, for example, if you want to include demo or test resources in the plugin repository, but not include them in the final distribution.<p class="paragraph"/>
<h2><a name="12.5 Evaluating Conventions">12.5 Evaluating Conventions</a></h2>Before moving onto looking at providing runtime configuration based on conventions you first need to understand how to evaluated those conventions from a plug-in. Essentially every plugin has an implicit <code>application</code> variable which is an instance of the api:org.codehaus.groovy.grails.commons.GrailsApplication interface.<p class="paragraph"/>The <code>GrailsApplication</code> interface provides methods to evaluate the conventions within the project and internally stores references to all classes within a GrailsApplication using the api:org.codehaus.groovy.grails.commons.GrailsClass interface.<p class="paragraph"/>A <code>GrailsClass</code> represents a physical Grails resources such as a controller or a tag library. For example to get all <code>GrailsClass</code> instances you can do:<p class="paragraph"/><div class="code"><pre>application.allClasses.each &#123; println it.name &#125;</pre></div><p class="paragraph"/>There are a few "magic" properties that the <code>GrailsApplication</code> instance possesses that allow you to narrow the type of artefact you are interested in. For example if you only want to controllers you can do:<p class="paragraph"/><div class="code"><pre>application.controllerClasses.each &#123; println it.name &#125;</pre></div><p class="paragraph"/>The dynamic method conventions are as follows:
<ul class="star">
<li><code>*Classes</code> - Retrieves all the classes for a particular artefact name. Example <code>application.controllerClasses</code>.</li>
<li><code>get*Class</code> - Retrieves a named class for a particular artefact. Example <code>application.getControllerClass("ExampleController")</code></li>
<li><code>is*Class</code> - Returns true if the given class is of the given artefact type. Example <code>application.isControllerClass(ExampleController.class)</code></li>
<li><code>add*Class</code> - Adds a class for the given artefact type and returns the added <code>GrailsClass</code> instance - Example <code>application.addControllerClass(ExampleController.class)</code></li>
</ul><p class="paragraph"/>The <code>GrailsClass</code> interface itself provides a number of useful methods that allow you to further evaluate and work with the conventions. These include:
<ul class="star">
<li><code>getPropertyValue</code> - Gets the initial value of the given property on the class</li>
<li><code>hasProperty</code> - Returns true if the class has the specified property</li>
<li><code>newInstance</code> - Creates a new instance of this class.</li>
<li><code>getName</code> -  Returns the logical name of the class in the application without the trailing convention part if applicable</li>
<li><code>getShortName</code> - Returns the short name of the class without package prefix</li>
<li><code>getFullName</code> - Returns the full name of the class in the application with the trailing convention part and with the package name</li>
<li><code>getPropertyName</code> - Returns the name of the class as a property name</li>
<li><code>getLogicalPropertyName</code> - Returns the logical property name of the class in the application without the trailing convention part if applicable</li>
<li><code>getNaturalName</code> - Returns the name of the property in natural terms (eg. 'lastName' becomes 'Last Name')</li>
<li><code>getPackageName</code> - Returns the package name</li>
</ul><p class="paragraph"/>For a full reference refer to the api:org.codehaus.groovy.grails.commons.GrailsClass.<h2><a name="12.6 Hooking into Build Events">12.6 Hooking into Build Events</a></h2><h4>Post-Install Configuration and Participating in Upgrades</h4><p class="paragraph"/>Grails plug-ins can do post-install configuration and participate in application upgrade process (the <a href="../ref/Command Line/upgrade.html" class="commandLine">upgrade</a> command). This is achieved via two specially named scripts under <code>scripts</code> directory of the plugin - <code>_Install.groovy</code> and <code>_Upgrade.groovy</code>.<p class="paragraph"/><code>_Install.groovy</code> is executed after the plugin has been installed and <code>_Upgrade.groovy</code> is executed each time the user upgrades his application with <a href="../ref/Command Line/upgrade.html" class="commandLine">upgrade</a> command.<p class="paragraph"/>These scripts are normal <a href="../guide/single.html#4. The Command Line" class="guide">Gant</a> scripts so you can use the full power of Gant. An addition to the standard Gant variables is the <code>pluginBasedir</code> variable which points at the plugin installation basedir.<p class="paragraph"/>As an example the below <code>_Install.groovy</code>  script will create a new directory type under the <code>grails-app</code> directory and install a configuration template:<p class="paragraph"/><div class="code"><pre>Ant.mkdir(dir:<span class="java&#45;quote">"$&#123;basedir&#125;/grails&#45;app/jobs"</span>)
Ant.copy(file:<span class="java&#45;quote">"$&#123;pluginBasedir&#125;/src/samples/SamplePluginConfiguration.groovy"</span>,
         todir:<span class="java&#45;quote">"$&#123;basedir&#125;/grails&#45;app/conf"</span>)<p class="paragraph"/>// To access Grails home you can use following code:
// Ant.property(environment:<span class="java&#45;quote">"env"</span>)
// grailsHome = Ant.antProject.properties.<span class="java&#45;quote">"env.GRAILS_HOME"</span></pre></div><p class="paragraph"/>
<h4>Scripting events</h4><p class="paragraph"/>It is also possible to hook into command line scripting events through plug-ins. These are events triggered during execution of Grails target and plugin scripts.<p class="paragraph"/>For example, you can hook into status update output (i.e. "Tests passed", "Server running") and the creation of files or artefacts.<p class="paragraph"/>A plug-in merely has to provide an <code>_Events.groovy</code> script to listen to the required events. Refer the documentation on <a href="../guide/single.html#4.3 Hooking into Events" class="guide">Hooking into Events</a> for further information.<h2><a name="12.7 Hooking into Runtime Configuration">12.7 Hooking into Runtime Configuration</a></h2>Grails provides a number of hooks to leverage the different parts of the system and perform runtime configuration by convention.<p class="paragraph"/><h4>Hooking into the Grails Spring configuration</h4><p class="paragraph"/>First, you can hook in Grails runtime configuration by providing a property called <code>doWithSpring</code> which is assigned a block of code. For example the following snippet is from one of the core Grails plugins that provides <a href="../guide/single.html#10. Internationalization" class="guide">i18n</a> support:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> org.springframework.web.servlet.i18n.CookieLocaleResolver;
<span class="java&#45;keyword">import</span> org.springframework.web.servlet.i18n.LocaleChangeInterceptor;
<span class="java&#45;keyword">import</span> org.springframework.context.support.ReloadableResourceBundleMessageSource;<p class="paragraph"/>class I18nGrailsPlugin &#123;<p class="paragraph"/>	def version = 0.1<p class="paragraph"/>	def doWithSpring = &#123;
		messageSource(ReloadableResourceBundleMessageSource) &#123;
			basename = <span class="java&#45;quote">"WEB&#45;INF/grails&#45;app/i18n/messages"</span>
		&#125;
		localeChangeInterceptor(LocaleChangeInterceptor) &#123;
			paramName = <span class="java&#45;quote">"lang"</span>
		&#125;
		localeResolver(CookieLocaleResolver)
	&#125;
&#125;</pre></div><p class="paragraph"/>This plugin sets up the Grails <code>messageSource</code> bean and a couple of other beans to manage Locale resolution and switching. It using the <a href="../guide/single.html#14. Grails and Spring" class="guide">Spring Bean Builder</a> syntax to do so.<p class="paragraph"/><h4>Participating in web.xml Generation</h4><p class="paragraph"/>Grails generates the <code>WEB-INF/web.xml</code> file at load time, and although plugins cannot change this file directly, they can participate in the generation of the file. Essentially a plugin can provide a <code>doWithWebDescriptor</code> property that is assigned a block of code that gets passed the <code>web.xml</code> as a <code>XmlSlurper</code> <code>GPathResult</code>.<p class="paragraph"/>Consider the below example from the <code>ControllersPlugin</code>:<p class="paragraph"/><div class="code"><pre>def doWithWebDescriptor = &#123; webXml &#45;&#62;
	def mappingElement = webXml.'servlet&#45;mapping'
	mappingElement + &#123;
		'servlet&#45;mapping' &#123;
			'servlet&#45;name'(<span class="java&#45;quote">"grails"</span>)
			'url&#45;pattern'(<span class="java&#45;quote">"&#42;.dispatch"</span>)
		&#125;
	&#125;
&#125;</pre></div><p class="paragraph"/>Here the plugin goes through gets a reference to the last <code>&#60;servlet-mapping&#62;</code> element and appends Grails' servlet to the end of it using XmlSlurper's ability to programmatically modify XML using closures and blocks.<p class="paragraph"/>
<h4>Doing Post Initialisation Configuration</h4><p class="paragraph"/>Sometimes it is useful to be able do some runtime configuration after the Spring <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/context/ApplicationContext.html" class="api">ApplicationContext</a> has been built. In this case you can define a <code>doWithApplicationContext</code> closure property.<p class="paragraph"/><div class="code"><pre>class SimplePlugin &#123;
     def name=<span class="java&#45;quote">"simple"</span>
     def version = 1.1<p class="paragraph"/>	 def doWithApplicationContext = &#123; appCtx &#45;&#62;
          SessionFactory sf = appCtx.getBean(<span class="java&#45;quote">"sessionFactory"</span>)
          // <span class="java&#45;keyword">do</span> something here with session factory
	 &#125;
&#125;</pre></div><p class="paragraph"/><h2><a name="12.8 Adding Dynamic Methods at Runtime">12.8 Adding Dynamic Methods at Runtime</a></h2><h4>The Basics</h4><p class="paragraph"/>Grails plugins allow you to register dynamic methods with any Grails managed or other class at runtime. New methods can only be added within a <code>doWithDynamicMethods</code> closure of a plugin.<p class="paragraph"/>For Grails managed classes like controllers, tag libraries and so forth you can add methods, constructors etc. using the <a href="http://groovy.codehaus.org/ExpandoMetaClass" target="blank">ExpandoMetaClass</a> mechanism by accessing each controller's <a href="api:http://groovy.codehaus.org/api/groovy/lang/MetaObjectProtocol.html" target="blank">MetaClass</a>:<p class="paragraph"/><div class="code"><pre>class ExamplePlugin &#123;
  def doWithDynamicMethods = &#123; applicationContext &#45;&#62;
        application.controllerClasses.each &#123; controllerClass &#45;&#62;
             controllerClass.metaClass.myNewMethod = &#123;&#45;&#62; println <span class="java&#45;quote">"hello world"</span> &#125;
        &#125;
  &#125;
&#125;</pre></div><p class="paragraph"/>In this case we use the implicit application object to get a reference to all of the controller classes' MetaClass instances and then add a new method called <code>myNewMethod</code> to each controller.
Alternatively, if you know before hand the class you wish the add a method to you can simple reference that classes <code>metaClass</code> property:<p class="paragraph"/><div class="code"><pre>class ExamplePlugin &#123;<p class="paragraph"/>  def doWithDynamicMethods = &#123; applicationContext &#45;&#62;
      <span class="java&#45;object">String</span>.metaClass.swapCase = &#123;&#45;&#62;
           def sb = <span class="java&#45;keyword">new</span> <span class="java&#45;object">StringBuffer</span>()
           delegate.each &#123;
               sb &#60;&#60; (<span class="java&#45;object">Character</span>.isUpperCase(it as <span class="java&#45;object">char</span>) ? 
                      <span class="java&#45;object">Character</span>.toLowerCase(it as <span class="java&#45;object">char</span>) : 
                      <span class="java&#45;object">Character</span>.toUpperCase(it as <span class="java&#45;object">char</span>))
           &#125;
           sb.toString()
      &#125;<p class="paragraph"/>      assert <span class="java&#45;quote">"UpAndDown"</span> == <span class="java&#45;quote">"uPaNDdOWN"</span>.swapCase()       
  &#125;
&#125;</pre></div><p class="paragraph"/>In this example we add a new method <code>swapCase</code> to <code>java.lang.String</code> directly by accessing its <code>metaClass</code>.<p class="paragraph"/><h4>Interacting with the ApplicationContext</h4><p class="paragraph"/>The <code>doWithDynamicMethods</code> closure gets passed the Spring <code>ApplicationContext</code> instance. This is useful as it allows you to interact with objects within it. For example if you where implementing a method to interact with Hibernate you could use the <code>SessionFactory</code> instance in combination with a <code>HibernateTemplate</code>:<p class="paragraph"/>
<div class="code"><pre><span class="java&#45;keyword">import</span> org.springframework.orm.hibernate3.HibernateTemplate<p class="paragraph"/>class ExampleHibernatePlugin &#123;<p class="paragraph"/>   def doWithDynamicMethods = &#123; applicationContext &#45;&#62;<p class="paragraph"/>       application.domainClasses.each &#123; domainClass &#45;&#62;<p class="paragraph"/>           domainClass.metaClass.<span class="java&#45;keyword">static</span>.load = &#123; <span class="java&#45;object">Long</span> id&#45;&#62; 
                def sf = applicationContext.sessionFactory
                def template = <span class="java&#45;keyword">new</span> HibernateTemplate(sf)
				template.load(delegate, id)
           &#125;
       &#125;
   &#125;
&#125;</pre></div><p class="paragraph"/>Also because of the autowiring and dependency injection capability of the Spring container you can implement more powerful dynamic constructors that use the application context to wire dependencies into your object at runtime:<p class="paragraph"/><div class="code"><pre>class MyConstructorPlugin &#123;<p class="paragraph"/>    def doWithDynamicMethods = &#123; applicationContext &#45;&#62;
         application.domainClasses.each &#123; domainClass &#45;&#62;
              domainClass.metaClass.constructor = &#123;&#45;&#62;
                  <span class="java&#45;keyword">return</span> applicationContext.getBean(domainClass.name)
              &#125;
         &#125;<p class="paragraph"/>    &#125;
&#125;</pre></div><p class="paragraph"/>Here we actually replace the default constructor with one that looks up prototyped Spring beans instead!<p class="paragraph"/><h2><a name="12.9 Participating in Auto Reload Events">12.9 Participating in Auto Reload Events</a></h2><h4>Monitoring Resources for Changes</h4><p class="paragraph"/>Often it is valuable to monitor resources for changes and then reload those changes when they occur. This is how Grails implements advanced reloading of application state at runtime. For example, consider the below simplified snippet from the <code>ServicesPlugin</code> that Grails comes with:<p class="paragraph"/><div class="code"><pre>class ServicesGrailsPlugin &#123;
    &#8230;
    def watchedResources = <span class="java&#45;quote">"file:./grails&#45;app/services/&#42;Service.groovy"</span><p class="paragraph"/>    &#8230;
  def onChange = &#123; event &#45;&#62;
    <span class="java&#45;keyword">if</span>(event.source) &#123;
      def serviceClass = application.addServiceClass(event.source)
      def serviceName = <span class="java&#45;quote">"$&#123;serviceClass.propertyName&#125;"</span>
      def beans = beans &#123;
           <span class="java&#45;quote">"$serviceName"</span>(serviceClass.getClazz()) &#123; bean &#45;&#62;
               bean.autowire =  <span class="java&#45;keyword">true</span>
      &#125;
            &#125;
      <span class="java&#45;keyword">if</span>(event.ctx) &#123;
        event.ctx.registerBeanDefinition(serviceName,
                                       beans.getBeanDefinition(serviceName))
      &#125;
    &#125;
  &#125;
&#125;</pre></div><p class="paragraph"/>Firstly it defines a set of <code>watchedResources</code> as either a String or a List of strings that contain either the references or patterns of the resources to watch. If the watched resources is a Groovy file, when it is changed it will automatically be reloaded and passed into the <code>onChange</code> closure inside the <code>event</code> object.<p class="paragraph"/>The <code>event</code> object defines a number of useful properties:
<ul class="star">
<li><code>event.source</code> - The source of the event which is either the reloaded class or a Spring Resource</li>
<li><code>event.ctx</code> - The Spring <code>ApplicationContext</code> instance</li>
<li><code>event.plugin</code> - The plugin object that manages the resource (Usually this)</li>
<li><code>event.application</code> - The <code>GrailsApplication</code> instance</li>
</ul><p class="paragraph"/>From these objects you can evaluate the conventions and then apply the appropriate changes to the <code>ApplicationContext</code> and so forth based on the conventions, etc.  In the "Services" example above, a new services bean is re-registered with the <code>ApplicationContext</code> when one of the service classes changes.<p class="paragraph"/><h4>Influencing Other Plugins</h4><p class="paragraph"/>As well as being able to react to changes that occur when a plugin changes, sometimes one plugin needs to "influence" another plugin.<p class="paragraph"/>Take for example the Services &#38; Controllers plugins. When a service is reloaded, unless you reload the controllers too, problems will occur when you try to auto-wire the reloaded service into an older controller Class.<p class="paragraph"/>To get round this, you can specify which plugins another plugin "influences". What this means is that when one plugin detects a change, it will reload itself and then reload all influenced plugins. See this snippet from the <code>ServicesGrailsPlugin</code>:<p class="paragraph"/><div class="code"><pre>def influences = &#91;'controllers'&#93;</pre></div><p class="paragraph"/><h4>Observing other plugins</h4><p class="paragraph"/>If there is a particular plugin that you would like to observe for changes but not necessary watch the resources that it monitors you can use the "observe" property:<p class="paragraph"/><div class="code"><pre>def observe = &#91;<span class="java&#45;quote">"hibernate"</span>&#93;</pre></div><p class="paragraph"/>In this case when a Hibernate domain class is changed you will also receive the event chained from the hibernate plugin. It is also possible for a plugin to observe all loaded plugins by using a wildcard:<p class="paragraph"/><div class="code"><pre>def observe = &#91;<span class="java&#45;quote">"&#42;"</span>&#93;</pre></div><p class="paragraph"/>The Logging plugin does exactly this so that it can add the <code>log</code> property back to <em class="italic">any</em> artefact that changes while the application is running.<h2><a name="12.10 Understanding Plug-in Load Order">12.10 Understanding Plug-in Load Order</a></h2><h4>Controlling Plug-in Dependencies</h4><p class="paragraph"/>Plug-ins often depend on the presence of other plugins and can also adapt depending on the presence of others. To cover this, a plugin can define two properties. The first is called <code>dependsOn</code>. For example, take a look at this snippet from the Grails Hibernate plugin:<p class="paragraph"/><div class="code"><pre>class HibernateGrailsPlugin &#123;
	def version = 1.0
	def dependsOn = &#91;dataSource:1.0,
	                 domainClass:1.0,
	                 i18n:1.0,
	                 core: 1.0&#93;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>As the above example demonstrates the Hibernate plugin is dependent on the presence of 4 plugins: The <code>dataSource</code> plugin, The <code>domainClass</code> plugin, the <code>i18n</code> plugin and the <code>core</code> plugin.<p class="paragraph"/>Essentially the dependencies will be loaded first and then the Hibernate plugin. If all dependencies do not load, then the plugin will not load.<p class="paragraph"/>The <code>dependsOn</code> property also supports a mini expression language for specifying version ranges. A few examples of the syntax can be seen below:<p class="paragraph"/><div class="code"><pre>def dependsOn = &#91;foo:<span class="java&#45;quote">"&#42; &#62; 1.0"</span>&#93;
def dependsOn = &#91;foo:<span class="java&#45;quote">"1.0 &#62; 1.1"</span>&#93;
def dependsOn = &#91;foo:<span class="java&#45;quote">"1.0 &#62; &#42;"</span>&#93;</pre></div><p class="paragraph"/>When the wildcard * character is used it denotes "any" version. The expression syntax also excludes any suffixes such as -BETA, -ALPHA etc. so for example the expression "1.0 &#62; 1.1" would match any of the following versions:
<ul class="star">
<li>1.1</li>
<li>1.0</li>
<li>1.0.1</li>
<li>1.0.3-SNAPSHOT</li>
<li>1.1-BETA2</li>
</ul><p class="paragraph"/><h4>Controlling Load Order </h4><p class="paragraph"/>Using <code>dependsOn</code> establishes a "hard" dependency in that if the dependency is not resolved, the plugin will give up and won't load.  It is possible though to have a "weaker" dependency using the <code>loadAfter</code> property:<p class="paragraph"/><div class="code"><pre>def loadAfter = &#91;'controllers'&#93;</pre></div><p class="paragraph"/>Here the plugin will be loaded after the <code>controllers</code> plugin if it exists, otherwise it will just be loaded. The plugin can then adapt to the presence of the other plugin, for example the Hibernate plugin has this code in the <code>doWithSpring</code> closure:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">if</span>(manager?.hasGrailsPlugin(<span class="java&#45;quote">"controllers"</span>)) &#123;
	openSessionInViewInterceptor(OpenSessionInViewInterceptor) &#123;
        	flushMode = HibernateAccessor.FLUSH_MANUAL
	        sessionFactory = sessionFactory
	&#125;
        grailsUrlHandlerMapping.interceptors &#60;&#60; openSessionInViewInterceptor
  &#125;</pre></div><p class="paragraph"/>Here the Hibernate plugin will only register an <code>OpenSessionInViewInterceptor</code> if the <code>controllers</code> plugin has been loaded. The manager variable is an instance of the api:org.codehaus.groovy.grails.plugins.GrailsPluginManager interface and it provides methods to interact with other plugins and the <code>GrailsPluginManager</code> itself from any plugin.
	</body>
</html>